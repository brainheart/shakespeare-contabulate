<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Shakespeare Tabular Search</title>
  <style>
    :root {
      --parchment: #f9f7f1;
      --ink: #2b2b2b;
      --burgundy: #8b1538;
      --gold: #d4af37;
      --border: #d4c5b0;
      --shadow: rgba(43, 43, 43, 0.08);
    }
    body { 
      font-family: 'Crimson Text', 'Georgia', 'Garamond', serif;
      margin: 0;
      padding: 2rem;
      background: linear-gradient(to bottom, var(--parchment) 0%, #fefdfb 100%);
      color: var(--ink);
      line-height: 1.6;
      max-width: 1400px;
      margin: 0 auto;
    }
    h1 { 
      font-family: 'Cinzel', 'Georgia', serif;
      color: var(--burgundy);
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
      text-shadow: 1px 1px 2px rgba(139, 21, 56, 0.1);
    }
    h1 a {
      color: var(--burgundy);
      text-decoration: none;
      border-bottom: 2px solid transparent;
      transition: border-color 0.2s;
    }
    h1 a:hover {
      border-bottom-color: var(--gold);
    }
    code {
      background: rgba(212, 175, 55, 0.1);
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.9em;
    }
    input[type="text"] { 
      padding: 0.6rem 0.8rem;
      font-size: 1rem;
      width: 26rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: white;
      font-family: 'Georgia', serif;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: var(--burgundy);
      box-shadow: 0 0 0 3px rgba(139, 21, 56, 0.1);
    }
    select, button { 
      padding: 0.5rem 0.8rem;
      font-size: 1rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: white;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s;
    }
    button {
      background: var(--burgundy);
      color: white;
      border-color: var(--burgundy);
      font-weight: 500;
      letter-spacing: 0.3px;
    }
    button:hover {
      background: #6d1028;
      box-shadow: 0 2px 4px var(--shadow);
    }
    select:hover {
      border-color: var(--burgundy);
    }
    table { 
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
      background: white;
      box-shadow: 0 1px 3px var(--shadow);
      border-radius: 6px;
      overflow: hidden;
    }
    th, td { 
      border: 1px solid var(--border);
      padding: 0.7rem 0.8rem;
      text-align: left;
    }
    th { 
      background: linear-gradient(to bottom, #faf8f3 0%, #f0ede5 100%);
      position: sticky;
      top: 0;
      cursor: pointer;
      user-select: none;
      font-weight: 600;
      color: var(--burgundy);
      letter-spacing: 0.3px;
      font-size: 0.95rem;
      border-bottom: 2px solid var(--border);
    }
    th:hover { 
      background: linear-gradient(to bottom, #f5f2ea 0%, #e8e4d8 100%);
    }
    th.sorted-asc::after { content: ' ▲'; color: var(--burgundy); }
    th.sorted-desc::after { content: ' ▼'; color: var(--burgundy); }
    tbody tr:hover {
      background: rgba(212, 175, 55, 0.05);
    }
    tbody tr:nth-child(even) {
      background: rgba(249, 247, 241, 0.3);
    }
    tbody tr:nth-child(even):hover {
      background: rgba(212, 175, 55, 0.08);
    }
    .controls { 
      display:flex;
      flex-wrap: wrap;
      gap: .75rem;
      align-items: center;
      margin-bottom: 1rem;
      padding: 1rem;
      background: white;
      border-radius: 6px;
      box-shadow: 0 1px 3px var(--shadow);
      border: 1px solid var(--border);
    }
    .muted { 
      color: #665544;
      font-size: 0.95rem;
      font-style: italic;
    }
    .chip { 
      display:inline-block;
      padding: 0.2rem 0.7rem;
      background: rgba(212, 175, 55, 0.15);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 1rem;
      font-size: 0.9rem;
      color: var(--ink);
    }
    #playsFilter { 
      max-height: 8rem;
      overflow:auto;
      border: 1px solid var(--border);
      padding: 0.7rem;
      border-radius: 4px;
      background: white;
    }
    details {
      background: white;
      padding: 0.5rem;
      border-radius: 6px;
      border: 1px solid var(--border);
      margin-bottom: 1rem;
      box-shadow: 0 1px 3px var(--shadow);
    }
    summary {
      cursor: pointer;
      padding: 0.5rem;
      user-select: none;
    }
    summary:hover {
      color: var(--burgundy);
    }
    #details { 
      margin-top: 1.5rem;
      padding: 1rem;
      background: white;
      border-radius: 6px;
      border: 1px solid var(--border);
      box-shadow: 0 1px 3px var(--shadow);
    }
    .hit { 
      background: rgba(212, 175, 55, 0.3);
      padding: 0 0.2rem;
      border-radius: 2px;
    }
    .sr { 
      font-size: 0.95rem;
      color: #554433;
    }
    .warning { 
      color: var(--burgundy);
      font-size: 0.9rem;
      font-style: italic;
    }
    label {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      color: var(--ink);
      font-weight: 500;
    }
    input[type="checkbox"] {
      width: 1.1rem;
      height: 1.1rem;
      cursor: pointer;
    }
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
      margin-bottom: 1rem;
      border-bottom: 2px solid var(--border);
    }
    .tab-btn {
      padding: 0.7rem 1.2rem;
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      color: var(--ink);
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
      margin-bottom: -2px;
    }
    .tab-btn:hover {
      background: rgba(139, 21, 56, 0.05);
      color: var(--burgundy);
    }
    .tab-btn.active {
      color: var(--burgundy);
      border-bottom-color: var(--burgundy);
      background: transparent;
    }
    .tab-content {
      margin-top: 0;
    }
    .tab-content .controls {
      margin-top: 0;
    }
    .pagination {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-top: 1rem;
      padding: 0.75rem;
      background: white;
      border-radius: 6px;
      border: 1px solid var(--border);
      box-shadow: 0 1px 3px var(--shadow);
    }
    .pagination button {
      padding: 0.4rem 0.8rem;
      min-width: 2.5rem;
    }
    .pagination button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background: #ddd;
    }
    .pagination select {
      padding: 0.4rem 0.6rem;
    }
    .pagination .page-info {
      color: var(--ink);
      font-weight: 500;
    }
  </style>
</head>
<body>
  <h1><a href="../">Contabulate</a>: Shakespeare Tabular Search</h1>
  <p class="muted">Search for single words, bigrams, or trigrams across plays, acts, scence, characters, genres. Use regular expression patterns (e.g., <code>love.*thee</code>) or literal text.</p>

  <div class="tabs">
    <button class="tab-btn active" data-tab="segments">Rows are Corpus Segments</button>
    <button class="tab-btn" data-tab="ngrams">Rows are Ngrams</button>
  </div>

  <div class="tab-content" id="segmentsTab">
    <div class="controls">
      <label>Query <input id="q" type="text" placeholder="e.g., blood | mortal coil | love.*thee" value="death"></label>
      <label>Granularity
        <select id="gran">
          <option value="play">Play</option>
          <option value="act">Act</option>
          <option value="scene" selected>Scene</option>
          <option value="genre">Genre</option>
          <option value="character">Character</option>
        </select>
      </label>
      <label title="Force search in specific n-gram index (auto-detects by default)">
        N-gram:
        <select id="ngramMode">
          <option value="auto" selected>Auto</option>
          <option value="1">Unigrams</option>
          <option value="2">Bigrams</option>
          <option value="3">Trigrams</option>
        </select>
      </label>
      <label><input type="checkbox" id="useRegex"> Regex mode</label>
      <button id="go">Search</button>
      <span id="status" class="chip">loading…</span>
      <span id="denom" class="muted"></span>
    </div>

    <details>
      <summary class="sr"><strong>Filters & Display</strong> (default: all)</summary>
      <div style="margin-bottom: 0.75rem;">
        <label style="font-weight: 500;">Minimum hits: <input type="number" id="minHits" value="0" min="0" style="width: 5rem; padding: 0.4rem;"></label>
      </div>
      <div id="playsFilter"></div>
    </details>

    <table id="results">
      <thead><tr id="headRow"></tr></thead>
      <tbody></tbody>
    </table>
    
    <div class="pagination" id="segmentsPagination" style="display: none;">
      <button id="segmentsFirstPage">First</button>
      <button id="segmentsPrevPage">Prev</button>
      <span class="page-info" id="segmentsPageInfo">Page 1 of 1</span>
      <button id="segmentsNextPage">Next</button>
      <button id="segmentsLastPage">Last</button>
      <label>
        Rows per page:
        <select id="segmentsPageSize">
          <option value="25">25</option>
          <option value="50" selected>50</option>
          <option value="100">100</option>
          <option value="250">250</option>
        </select>
      </label>
      <span class="page-info" id="segmentsTotalInfo"></span>
    </div>
  </div>

  <div class="tab-content" id="ngramsTab" style="display: none;">
    <div id="ngramTableContainer"></div>
    
    <div class="pagination" id="ngramsPagination" style="display: none;">
      <button id="ngramsFirstPage">First</button>
      <button id="ngramsPrevPage">Prev</button>
      <span class="page-info" id="ngramsPageInfo">Page 1 of 1</span>
      <button id="ngramsNextPage">Next</button>
      <button id="ngramsLastPage">Last</button>
      <label>
        Rows per page:
        <select id="ngramsPageSize">
          <option value="25">25</option>
          <option value="50">50</option>
          <option value="100" selected>100</option>
          <option value="250">250</option>
          <option value="500">500</option>
        </select>
      </label>
      <span class="page-info" id="ngramsTotalInfo"></span>
    </div>
  </div>

<script>
(async function() {
  const status = document.getElementById('status');
  const q = document.getElementById('q');
  const gran = document.getElementById('gran');
  const go = document.getElementById('go');
  const useRegex = document.getElementById('useRegex');
  const ngramMode = document.getElementById('ngramMode');
  const playsFilter = document.getElementById('playsFilter');
  const minHits = document.getElementById('minHits');
  const theadRow = document.getElementById('headRow');
  const tbody = document.querySelector('#results tbody');
  const ngramTableContainer = document.getElementById('ngramTableContainer');
  const denomText = document.getElementById('denom');

  // Tab switching
  const tabBtns = document.querySelectorAll('.tab-btn');
  const segmentsTab = document.getElementById('segmentsTab');
  const ngramsTab = document.getElementById('ngramsTab');
  
  tabBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const targetTab = btn.dataset.tab;
      tabBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      if (targetTab === 'segments') {
        segmentsTab.style.display = 'block';
        ngramsTab.style.display = 'none';
      } else {
        segmentsTab.style.display = 'none';
        ngramsTab.style.display = 'block';
      }
    });
  });

  async function loadJSON(path) {
    const res = await fetch(path);
    if (!res.ok) throw new Error(`Failed to load ${path}: ${res.status}`);
    return res.json();
  }

  let chunks=[], tokens={}, tokens2={}, tokens3={}, plays=[], characters=[], tokensChar={}, tokensChar2={}, tokensChar3={};
  try {
    [chunks, tokens, tokens2, tokens3, plays, characters, tokensChar, tokensChar2, tokensChar3] = await Promise.all([
      loadJSON('data/chunks.json'),
      loadJSON('data/tokens.json'),
      loadJSON('data/tokens2.json'),
      loadJSON('data/tokens3.json'),
      loadJSON('data/plays.json'),
      loadJSON('data/characters.json'),
      loadJSON('data/tokens_char.json'),
      loadJSON('data/tokens_char2.json'),
      loadJSON('data/tokens_char3.json'),
    ]);
    status.textContent = 'ready';
  } catch(e) {
    status.textContent = 'failed to load data';
    console.error(e);
    return;
  }

  const chunkById = new Map(chunks.map(r => [r.scene_id, r]));
  const playsById = new Map(plays.map(p => [p.play_id, p]));
  const charactersById = new Map(characters.map(c => [c.character_id, c]));

  function renderPlayFilter() {
    playsFilter.innerHTML = '';
    for (const p of plays) {
      const id = `play_${p.play_id}`;
      const div = document.createElement('div');
      div.innerHTML = `<label><input type="checkbox" id="${id}" data-play="${p.play_id}" checked> ${p.title} <span class="muted">(${p.genre || ''}${p.first_performance_year ? ', ' + p.first_performance_year : ''})</span></label>`;
      playsFilter.appendChild(div);
    }
  }
  renderPlayFilter();
  function selectedPlayIds() {
    const ids = [];
    playsFilter.querySelectorAll('input[type="checkbox"]').forEach(cb => { if (cb.checked) ids.push(Number(cb.dataset.play)); });
    return new Set(ids);
  }
  function fmtPct(num) { return (num*100).toFixed(2) + '%'; }

  // Pagination state
  let segmentsCurrentPage = 1;
  let segmentsPageSize = 50;
  let segmentsAllRows = [];
  
  let ngramsCurrentPage = 1;
  let ngramsPageSize = 100;
  let ngramsAllRows = [];

  // Pagination helper
  function paginateArray(arr, page, pageSize) {
    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    return arr.slice(start, end);
  }

  function getTotalPages(totalRows, pageSize) {
    return Math.max(1, Math.ceil(totalRows / pageSize));
  }

  const actTotals = new Map();
  const playTotals = new Map();
  for (const r of chunks) {
    const k = `${r.play_id}:${r.act}`;
    actTotals.set(k, (actTotals.get(k)||0) + (r.total_words||0));
    playTotals.set(r.play_id, (playTotals.get(r.play_id)||0) + (r.total_words||0));
  }

  let sortKey = null, sortDir = 'desc';
  function setHeaders(cols){
    theadRow.innerHTML='';
    cols.forEach(c => {
      const th = document.createElement('th');
      th.textContent = c.label;
      th.dataset.key = c.key;
      th.title = 'Click to sort';
      th.addEventListener('click', () => {
        if (sortKey === c.key) sortDir = (sortDir === 'asc' ? 'desc' : 'asc');
        else { sortKey = c.key; sortDir = c.defaultDir || 'desc'; }
        segmentsAllRows = sortRows(segmentsAllRows);
        segmentsCurrentPage = 1;
        renderSegmentsPage();
      });
      theadRow.appendChild(th);
    });
    updateSortIndicators();
  }
  
  function updateSortIndicators(){
    theadRow.querySelectorAll('th').forEach(th => {
      th.classList.remove('sorted-asc', 'sorted-desc');
      if (th.dataset.key === sortKey) {
        th.classList.add(sortDir === 'asc' ? 'sorted-asc' : 'sorted-desc');
      }
    });
  }
  function sortRows(rows){
    if (!sortKey) return rows;
    rows.sort((a,b) => {
      const av = a[sortKey], bv = b[sortKey];
      if (typeof av === 'string' || typeof bv === 'string') {
        return sortDir === 'asc' ? String(av).localeCompare(String(bv)) : String(bv).localeCompare(String(av));
      }
      return sortDir === 'asc' ? (av - bv) : (bv - av);
    });
    return rows;
  }

  function denomFor(n, levelKey, meta){
    const tw = (levelKey==='scene') ? (meta.total_words||0)
               : (levelKey==='act') ? (actTotals.get(`${meta.play_id}:${meta.act}`)||0)
               : (levelKey==='play') ? (playTotals.get(meta.play_id)||0)
               : (levelKey==='character') ? (meta.total_words_spoken||0) : 0;
    return Math.max(0, tw - (n-1));
  }

  function aggregatePostings(postingsArray, n) {
    // Merge multiple token postings (for regex matches)
    const merged = new Map();
    for (const postings of postingsArray) {
      for (const [id, count] of postings) {
        merged.set(id, (merged.get(id) || 0) + count);
      }
    }
    return Array.from(merged.entries());
  }

  function buildRows(query){
    const isRegex = useRegex.checked;
    const ngramModeVal = ngramMode.value;
    const terms = query.trim().toLowerCase().split(/\s+/).filter(Boolean);
    let n = Math.min(terms.length, 3);
    
    // Override n if user explicitly selected n-gram mode
    if (ngramModeVal !== 'auto') {
      n = parseInt(ngramModeVal);
    }

    const playsSel = selectedPlayIds();
    const granVal = gran.value;

    // Character view limitation
    if (granVal === 'character' && n > 3) {
      theadRow.innerHTML = '';
      tbody.innerHTML = '<tr><td class="muted">Character view supports up to trigrams.</td></tr>';
      return null;
    }

    const idx = (granVal === 'character') 
      ? (n === 1 ? tokensChar : n === 2 ? tokensChar2 : tokensChar3)
      : (n === 1 ? tokens : n === 2 ? tokens2 : tokens3);

    let allPostings = [];

    if (isRegex) {
      // Regex mode: match pattern against all token keys
      try {
        const pattern = new RegExp(query.trim(), 'i');
        const matchingKeys = Object.keys(idx).filter(k => pattern.test(k));
        
        if (matchingKeys.length === 0) {
          theadRow.innerHTML = '';
          tbody.innerHTML = '<tr><td class="muted">No tokens matched regex pattern.</td></tr>';
          denomText.textContent = '';
          return null;
        }
        
        // Show warning if too many matches (performance)
        if (matchingKeys.length > 1000) {
          denomText.textContent = '⚠️ Pattern matched ' + matchingKeys.length + ' tokens (showing aggregated results)';
        }

        // Aggregate all matching tokens
        allPostings = aggregatePostings(matchingKeys.map(k => idx[k]), n);
      } catch (e) {
        theadRow.innerHTML = '';
        tbody.innerHTML = `<tr><td class="warning">Invalid regex: ${e.message}</td></tr>`;
        return null;
      }
    } else {
      // Literal mode: exact match
      const key = terms.slice(0, n).join(' ');
      allPostings = idx[key] || [];
    }

    const rows = [];

    if (granVal==='scene'){
      for (const [scene_id, count] of allPostings){
        const m = chunkById.get(scene_id); if (!m || !playsSel.has(m.play_id)) continue;
        const d = denomFor(n,'scene',m);
        rows.push({ play_title: m.play_title, genre:m.genre, play_id:m.play_id, act:m.act, scene:m.scene, count, pct: d? count/d : 0, scene_id });
      }
      setHeaders([
        {key:'play_title', label:'Play', defaultDir:'asc'},
        {key:'act', label:'Act'},
        {key:'scene', label:'Scene'},
        {key:'count', label:'Hits'},
        {key:'pct', label:`% of ${n===1?'scene words':n===2?'scene bigrams':'scene trigrams'}`},
      ]);
      denomText.textContent = n===1?'Denominator: total words in scene':'Denominator: total contiguous '+(n===2?'bigrams':'trigrams')+' in scene';
      return rows;
    }

    if (granVal==='act'){
      const tmp = new Map();
      for (const [scene_id,c] of allPostings){
        const m = chunkById.get(scene_id); if (!m || !playsSel.has(m.play_id)) continue;
        const k = `${m.play_id}:${m.act}`;
        tmp.set(k, (tmp.get(k)||0) + c);
      }
      for (const [k,count] of tmp.entries()){
        const [pid, actNum] = k.split(':').map(Number);
        const play = playsById.get(pid);
        const denom = denomFor(n,'act',{play_id:pid,act:actNum});
        rows.push({ play_title: play.title, genre:play.genre, play_id:pid, act:actNum, count, pct: denom? count/denom : 0 });
      }
      setHeaders([
        {key:'play_title', label:'Play', defaultDir:'asc'},
        {key:'act', label:'Act'},
        {key:'count', label:'Hits'},
        {key:'pct', label:`% of ${n===1?'act words':n===2?'act bigrams':'act trigrams'}`},
      ]);
      denomText.textContent = n===1?'Denominator: total words in act':'Denominator: total contiguous '+(n===2?'bigrams':'trigrams')+' in act';
      return rows;
    }

    if (granVal==='play'){
      const tmp = new Map();
      for (const [scene_id,c] of allPostings){
        const m = chunkById.get(scene_id); if (!m || !playsSel.has(m.play_id)) continue;
        tmp.set(m.play_id, (tmp.get(m.play_id)||0) + c);
      }
      for (const [pid,count] of tmp.entries()){
        const p = playsById.get(pid);
        const denom = denomFor(n,'play',{play_id:pid});
        const num_lines = p.total_lines ?? 0;
        const total_words = p.total_words ?? 0;
        rows.push({ play_id:pid, title:p.title, genre:p.genre, first_year:p.first_performance_year||'', num_lines, total_words, count, pct: denom? count/denom : 0 });
      }
      setHeaders([
        {key:'title', label:'Play', defaultDir:'asc'},
        {key:'genre', label:'Genre', defaultDir:'asc'},
        {key:'first_year', label:'Year'},
        {key:'num_lines', label:'# lines'},
        {key:'total_words', label:'Word count'},
        {key:'count', label:'Hits'},
        {key:'pct', label:`% of ${n===1?'play words':n===2?'play bigrams':'play trigrams'}`},
      ]);
      denomText.textContent = n===1?'Denominator: total words in play':'Denominator: total contiguous '+(n===2?'bigrams':'trigrams')+' in play';
      return rows;
    }

    if (granVal==='genre'){
      const tmp = new Map();
      const genreTotals = new Map();
      // Aggregate counts and totals by genre
      for (const [scene_id,c] of allPostings){
        const m = chunkById.get(scene_id); if (!m || !playsSel.has(m.play_id)) continue;
        const genre = m.genre || 'unknown';
        tmp.set(genre, (tmp.get(genre)||0) + c);
        genreTotals.set(genre, (genreTotals.get(genre)||0) + (m.total_words||0));
      }
      for (const [genre,count] of tmp.entries()){
        const totalWords = genreTotals.get(genre) || 0;
        const denom = Math.max(0, totalWords - (n-1));
        rows.push({ genre, total_words: totalWords, count, pct: denom? count/denom : 0 });
      }
      setHeaders([
        {key:'genre', label:'Genre', defaultDir:'asc'},
        {key:'total_words', label:'Word count'},
        {key:'count', label:'Hits'},
        {key:'pct', label:`% of ${n===1?'genre words':n===2?'genre bigrams':'genre trigrams'}`},
      ]);
      denomText.textContent = n===1?'Denominator: total words in genre':'Denominator: total contiguous '+(n===2?'bigrams':'trigrams')+' in genre';
      return rows;
    }

    if (granVal==='character'){
      for (const [char_id, count] of allPostings){
        const c = charactersById.get(char_id);
        if (!c || !playsSel.has(c.play_id)) continue;
        const denom = denomFor(n,'character',c);
        rows.push({ play_title:c.play_title, name:c.name, total_words_spoken:c.total_words_spoken||0, count, pct: denom? count/denom : 0 });
      }
      setHeaders([
        {key:'play_title', label:'Play', defaultDir:'asc'},
        {key:'name', label:'Character', defaultDir:'asc'},
        {key:'count', label:'Hits'},
        {key:'pct', label:`% of character ${n===1?'words':n===2?'bigrams':'trigrams'}`},
        {key:'total_words_spoken', label:'Char. total words'},
      ]);
      denomText.textContent = n===1?'Denominator: total words spoken by character':'Denominator: total contiguous '+(n===2?'bigrams':'trigrams')+' spoken by character';
      return rows;
    }
  }

  function renderRows(rows){
    tbody.innerHTML='';
    if (!rows || rows.length===0){ 
      tbody.innerHTML = '<tr><td colspan="8" class="muted">No results.</td></tr>'; 
      document.getElementById('segmentsPagination').style.display = 'none';
      return; 
    }
    
    // Filter by minimum hits
    const minHitsVal = parseInt(minHits.value) || 0;
    if (minHitsVal > 0) {
      rows = rows.filter(r => (r.count || 0) >= minHitsVal);
    }
    if (rows.length === 0) { 
      tbody.innerHTML = '<tr><td colspan="8" class="muted">No results match the minimum hits filter.</td></tr>'; 
      document.getElementById('segmentsPagination').style.display = 'none';
      return; 
    }
    
    rows = sortRows(rows);
    updateSortIndicators();
    
    // Store all rows and reset to page 1
    segmentsAllRows = rows;
    segmentsCurrentPage = 1;
    
    renderSegmentsPage();
  }
  
  function renderSegmentsPage() {
    const totalPages = getTotalPages(segmentsAllRows.length, segmentsPageSize);
    const paginatedRows = paginateArray(segmentsAllRows, segmentsCurrentPage, segmentsPageSize);
    
    tbody.innerHTML = '';
    const cols = Array.from(theadRow.children).map(th => th.dataset.key);
    const firstColKey = cols[0];
    
    for (const r of paginatedRows) {
      const tr = document.createElement('tr');
      cols.forEach((k, idx) => {
        const td = document.createElement('td');
        if (k === 'pct') {
          td.textContent = fmtPct(r[k]||0);
        } else {
          td.textContent = r[k] ?? '';
        }
        // Make first column clickable for drill-down
        if (idx === 0 && r[k]) {
          td.style.cursor = 'pointer';
          td.style.color = 'var(--burgundy)';
          td.style.textDecoration = 'underline';
          td.style.fontWeight = '500';
          td.addEventListener('click', () => showDrillDown(r, firstColKey));
        }
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    }
    
    // Update pagination controls
    const paginationDiv = document.getElementById('segmentsPagination');
    paginationDiv.style.display = segmentsAllRows.length > 25 ? 'flex' : 'none';
    
    document.getElementById('segmentsPageInfo').textContent = `Page ${segmentsCurrentPage} of ${totalPages}`;
    document.getElementById('segmentsTotalInfo').textContent = `(${segmentsAllRows.length} total rows)`;
    
    document.getElementById('segmentsFirstPage').disabled = segmentsCurrentPage === 1;
    document.getElementById('segmentsPrevPage').disabled = segmentsCurrentPage === 1;
    document.getElementById('segmentsNextPage').disabled = segmentsCurrentPage === totalPages;
    document.getElementById('segmentsLastPage').disabled = segmentsCurrentPage === totalPages;
  }

  function showDrillDown(rowData, firstColKey) {
    const granVal = gran.value;
    const ngramModeVal = ngramMode.value;
    let n = (ngramModeVal === 'auto') ? 1 : parseInt(ngramModeVal);
    
    // Determine which token index to use
    const idx = (granVal === 'character') 
      ? (n === 1 ? tokensChar : n === 2 ? tokensChar2 : tokensChar3)
      : (n === 1 ? tokens : n === 2 ? tokens2 : tokens3);
    
    // Build frequency map for this specific entity
    const freqMap = new Map();
    
    if (granVal === 'play') {
      // Get all scenes in this play and aggregate tokens
      const playId = rowData.play_id;
      
      for (const [token, postings] of Object.entries(idx)) {
        let total = 0;
        if (Array.isArray(postings)) {
          for (const posting of postings) {
            const [scene_id, count] = posting;
            const chunk = chunkById.get(scene_id);
            if (chunk && chunk.play_id === playId) {
              total += count;
            }
          }
        }
        if (total > 0) freqMap.set(token, total);
      }
    } else if (granVal === 'genre') {
      // Get all scenes in this genre
      const genre = rowData.genre;
      for (const [token, postings] of Object.entries(idx)) {
        let total = 0;
        if (Array.isArray(postings)) {
          for (const posting of postings) {
            const [scene_id, count] = posting;
            const chunk = chunkById.get(scene_id);
            if (chunk && chunk.genre === genre) total += count;
          }
        }
        if (total > 0) freqMap.set(token, total);
      }
    } else if (granVal === 'act') {
      // Get all scenes in this act of this play
      const playId = rowData.play_id;
      const actNum = rowData.act;
      for (const [token, postings] of Object.entries(idx)) {
        let total = 0;
        if (Array.isArray(postings)) {
          for (const posting of postings) {
            const [scene_id, count] = posting;
            const chunk = chunkById.get(scene_id);
            if (chunk && chunk.play_id === playId && chunk.act === actNum) total += count;
          }
        }
        if (total > 0) freqMap.set(token, total);
      }
    } else if (granVal === 'scene') {
      // Get tokens in this specific scene
      const sceneId = rowData.scene_id;
      for (const [token, postings] of Object.entries(idx)) {
        if (Array.isArray(postings)) {
          for (const posting of postings) {
            const [scene_id, count] = posting;
            if (scene_id === sceneId) freqMap.set(token, count);
          }
        }
      }
    } else if (granVal === 'character') {
      // Get tokens spoken by this character
      const charName = rowData.name;
      const playTitle = rowData.play_title;
      // Find character_id
      let charId = null;
      for (const [id, c] of charactersById) {
        if (c.name === charName && c.play_title === playTitle) {
          charId = id;
          break;
        }
      }
      if (charId) {
        for (const [token, postings] of Object.entries(idx)) {
          if (Array.isArray(postings)) {
            for (const posting of postings) {
              const [char_id, count] = posting;
              if (char_id === charId) freqMap.set(token, count);
            }
          }
        }
      }
    }
    
    // Sort by frequency descending
    const sortedTokens = Array.from(freqMap.entries())
      .sort((a, b) => b[1] - a[1]);
    
    // Store all rows for pagination
    ngramsAllRows = sortedTokens;
    ngramsCurrentPage = 1;
    
    // Build HTML table
    const ngramLabel = n === 1 ? 'Unigram' : n === 2 ? 'Bigram' : 'Trigram';
    const entityLabel = rowData[firstColKey] || '';
    let html = `<h3>All ${ngramLabel}s: ${entityLabel}</h3>`;
    html += `<p class="muted">Showing ${sortedTokens.length} unique ${ngramLabel.toLowerCase()}s, sorted by frequency</p>`;
    html += '<table id="ngramsTable"><thead><tr><th style="width: 60%;">' + ngramLabel + '</th><th>Frequency</th></tr></thead><tbody id="ngramsTableBody"></tbody></table>';
    
    ngramTableContainer.innerHTML = html;
    
    // Render first page
    renderNgramsPage();
    
    // Switch to ngrams tab
    tabBtns.forEach(b => b.classList.remove('active'));
    document.querySelector('[data-tab="ngrams"]').classList.add('active');
    segmentsTab.style.display = 'none';
    ngramsTab.style.display = 'block';
    ngramsTab.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  function renderNgramsPage() {
    const totalPages = getTotalPages(ngramsAllRows.length, ngramsPageSize);
    const paginatedRows = paginateArray(ngramsAllRows, ngramsCurrentPage, ngramsPageSize);
    
    const tbody = document.getElementById('ngramsTableBody');
    if (!tbody) return;
    
    tbody.innerHTML = '';
    for (const [token, count] of paginatedRows) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${token}</td><td>${count}</td>`;
      tbody.appendChild(tr);
    }
    
    // Update pagination controls
    const paginationDiv = document.getElementById('ngramsPagination');
    paginationDiv.style.display = ngramsAllRows.length > 25 ? 'flex' : 'none';
    
    document.getElementById('ngramsPageInfo').textContent = `Page ${ngramsCurrentPage} of ${totalPages}`;
    document.getElementById('ngramsTotalInfo').textContent = `(${ngramsAllRows.length} total rows)`;
    
    document.getElementById('ngramsFirstPage').disabled = ngramsCurrentPage === 1;
    document.getElementById('ngramsPrevPage').disabled = ngramsCurrentPage === 1;
    document.getElementById('ngramsNextPage').disabled = ngramsCurrentPage === totalPages;
    document.getElementById('ngramsLastPage').disabled = ngramsCurrentPage === totalPages;
  }

  function doSearch(){
    const query = q.value.trim();
    if (!query){ tbody.innerHTML = ''; ngramTableContainer.innerHTML=''; denomText.textContent=''; return; }
    sortKey = 'count';
    sortDir = 'desc';
    const rows = buildRows(query);
    if (rows) renderRows(rows);
  }

  go.addEventListener('click', doSearch);
  q.addEventListener('keydown', e => { if (e.key==='Enter') doSearch(); });
  minHits.addEventListener('input', () => {
    const query = q.value.trim();
    if (query) renderRows(buildRows(query));
  });
  
  // Segments pagination controls
  document.getElementById('segmentsFirstPage').addEventListener('click', () => {
    segmentsCurrentPage = 1;
    renderSegmentsPage();
  });
  document.getElementById('segmentsPrevPage').addEventListener('click', () => {
    if (segmentsCurrentPage > 1) {
      segmentsCurrentPage--;
      renderSegmentsPage();
    }
  });
  document.getElementById('segmentsNextPage').addEventListener('click', () => {
    const totalPages = getTotalPages(segmentsAllRows.length, segmentsPageSize);
    if (segmentsCurrentPage < totalPages) {
      segmentsCurrentPage++;
      renderSegmentsPage();
    }
  });
  document.getElementById('segmentsLastPage').addEventListener('click', () => {
    segmentsCurrentPage = getTotalPages(segmentsAllRows.length, segmentsPageSize);
    renderSegmentsPage();
  });
  document.getElementById('segmentsPageSize').addEventListener('change', (e) => {
    segmentsPageSize = parseInt(e.target.value);
    segmentsCurrentPage = 1;
    renderSegmentsPage();
  });
  
  // Ngrams pagination controls
  document.getElementById('ngramsFirstPage').addEventListener('click', () => {
    ngramsCurrentPage = 1;
    renderNgramsPage();
  });
  document.getElementById('ngramsPrevPage').addEventListener('click', () => {
    if (ngramsCurrentPage > 1) {
      ngramsCurrentPage--;
      renderNgramsPage();
    }
  });
  document.getElementById('ngramsNextPage').addEventListener('click', () => {
    const totalPages = getTotalPages(ngramsAllRows.length, ngramsPageSize);
    if (ngramsCurrentPage < totalPages) {
      ngramsCurrentPage++;
      renderNgramsPage();
    }
  });
  document.getElementById('ngramsLastPage').addEventListener('click', () => {
    ngramsCurrentPage = getTotalPages(ngramsAllRows.length, ngramsPageSize);
    renderNgramsPage();
  });
  document.getElementById('ngramsPageSize').addEventListener('change', (e) => {
    ngramsPageSize = parseInt(e.target.value);
    ngramsCurrentPage = 1;
    renderNgramsPage();
  });

  // Auto-detect regex patterns
  q.addEventListener('input', () => {
    const val = q.value;
    const hasRegexChars = /[.*+?^${}()|[\]\\]/.test(val);
    if (hasRegexChars && !useRegex.checked) {
      useRegex.checked = true;
    }
  });

  // initial state
  gran.value = 'play';
  q.value = 'death';
  doSearch();
})();
</script>
</body>
</html>