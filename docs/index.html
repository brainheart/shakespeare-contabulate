<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Shakespeare Tabular Search</title>
  <style>
    :root {
      --parchment: #f9f7f1;
      --ink: #2b2b2b;
      --burgundy: #8b1538;
      --gold: #d4af37;
      --border: #d4c5b0;
      --shadow: rgba(43, 43, 43, 0.08);
    }
    body { 
      font-family: 'Crimson Text', 'Georgia', 'Garamond', serif;
      margin: 0;
      padding: 2rem;
      background: linear-gradient(to bottom, var(--parchment) 0%, #fefdfb 100%);
      color: var(--ink);
      line-height: 1.6;
      max-width: 1400px;
      margin: 0 auto;
    }
    h1 { 
      font-family: 'Cinzel', 'Georgia', serif;
      color: var(--burgundy);
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
      text-shadow: 1px 1px 2px rgba(139, 21, 56, 0.1);
    }
    h1 a {
      color: var(--burgundy);
      text-decoration: none;
      border-bottom: 2px solid transparent;
      transition: border-color 0.2s;
    }
    h1 a:hover {
      border-bottom-color: var(--gold);
    }
    code {
      background: rgba(212, 175, 55, 0.1);
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.9em;
    }
    input[type="text"] { 
      padding: 0.6rem 0.8rem;
      font-size: 1rem;
      width: 26rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: white;
      font-family: 'Georgia', serif;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: var(--burgundy);
      box-shadow: 0 0 0 3px rgba(139, 21, 56, 0.1);
    }
    select, button { 
      padding: 0.5rem 0.8rem;
      font-size: 1rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: white;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s;
    }
    button {
      background: var(--burgundy);
      color: white;
      border-color: var(--burgundy);
      font-weight: 500;
      letter-spacing: 0.3px;
    }
    button:hover {
      background: #6d1028;
      box-shadow: 0 2px 4px var(--shadow);
    }
    .download-btn {
      background: #0f5b4d;
      border-color: #0f5b4d;
    }
    .download-btn:hover {
      background: #0b4a3e;
    }
    select:hover {
      border-color: var(--burgundy);
    }
    table { 
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
      background: white;
      box-shadow: 0 1px 3px var(--shadow);
      border-radius: 6px;
      overflow: hidden;
    }
    th, td { 
      border: 1px solid var(--border);
      padding: 0.7rem 0.8rem;
      text-align: left;
    }
    th { 
      background: linear-gradient(to bottom, #faf8f3 0%, #f0ede5 100%);
      position: sticky;
      top: 0;
      cursor: pointer;
      user-select: none;
      font-weight: 600;
      color: var(--burgundy);
      letter-spacing: 0.3px;
      font-size: 0.95rem;
      border-bottom: 2px solid var(--border);
    }
    th:hover { 
      background: linear-gradient(to bottom, #f5f2ea 0%, #e8e4d8 100%);
    }
    th.sorted-asc::after { content: ' ▲'; color: var(--burgundy); }
    th.sorted-desc::after { content: ' ▼'; color: var(--burgundy); }
    tbody tr:hover {
      background: rgba(212, 175, 55, 0.05);
    }
    tbody tr:nth-child(even) {
      background: rgba(249, 247, 241, 0.3);
    }
    tbody tr:nth-child(even):hover {
      background: rgba(212, 175, 55, 0.08);
    }
    .controls { 
      display:flex;
      flex-wrap: wrap;
      gap: .75rem;
      align-items: center;
      margin-bottom: 1rem;
      padding: 1rem;
      background: white;
      border-radius: 6px;
      box-shadow: 0 1px 3px var(--shadow);
      border: 1px solid var(--border);
    }
    .muted { 
      color: #665544;
      font-size: 0.95rem;
      font-style: italic;
    }
    .chip { 
      display:inline-block;
      padding: 0.2rem 0.7rem;
      background: rgba(212, 175, 55, 0.15);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 1rem;
      font-size: 0.9rem;
      color: var(--ink);
    }
    .term-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
    }
    .term-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.6rem;
      background: rgba(139, 21, 56, 0.08);
      border: 1px solid rgba(139, 21, 56, 0.2);
      border-radius: 999px;
      font-size: 0.95rem;
      color: var(--ink);
    }
    .term-pill button {
      border: none;
      background: transparent;
      color: #5c1228;
      cursor: pointer;
      font-size: 1rem;
      padding: 0 0.2rem;
      line-height: 1;
    }
    .term-pill button:hover {
      color: #000;
    }
    #playsFilter { 
      max-height: 8rem;
      overflow:auto;
      border: 1px solid var(--border);
      padding: 0.7rem;
      border-radius: 4px;
      background: white;
    }
    details {
      background: white;
      padding: 0.5rem;
      border-radius: 6px;
      border: 1px solid var(--border);
      margin-bottom: 1rem;
      box-shadow: 0 1px 3px var(--shadow);
    }
    summary {
      cursor: pointer;
      padding: 0.5rem;
      user-select: none;
    }
    summary:hover {
      color: var(--burgundy);
    }
    #details { 
      margin-top: 1.5rem;
      padding: 1rem;
      background: white;
      border-radius: 6px;
      border: 1px solid var(--border);
      box-shadow: 0 1px 3px var(--shadow);
    }
    .hit { 
      background: rgba(212, 175, 55, 0.3);
      padding: 0 0.2rem;
      border-radius: 2px;
    }
    .sr { 
      font-size: 0.95rem;
      color: #554433;
    }
    .warning { 
      color: var(--burgundy);
      font-size: 0.9rem;
      font-style: italic;
    }
    label {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      color: var(--ink);
      font-weight: 500;
    }
    input[type="checkbox"] {
      width: 1.1rem;
      height: 1.1rem;
      cursor: pointer;
    }
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
      margin-bottom: 1rem;
      border-bottom: 2px solid var(--border);
    }
    .tab-btn {
      padding: 0.7rem 1.2rem;
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      color: var(--ink);
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
      margin-bottom: -2px;
    }
    .tab-btn:hover {
      background: rgba(139, 21, 56, 0.05);
      color: var(--burgundy);
    }
    .tab-btn.active {
      color: var(--burgundy);
      border-bottom-color: var(--burgundy);
      background: transparent;
    }
    .tab-content {
      margin-top: 0;
    }
    .tab-content .controls {
      margin-top: 0;
    }
    .pagination {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-top: 1rem;
      padding: 0.75rem;
      background: white;
      border-radius: 6px;
      border: 1px solid var(--border);
      box-shadow: 0 1px 3px var(--shadow);
    }
    .pagination button {
      padding: 0.4rem 0.8rem;
      min-width: 2.5rem;
    }
    .pagination button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background: #ddd;
    }
    .pagination select {
      padding: 0.4rem 0.6rem;
    }
    .pagination .page-info {
      color: var(--ink);
      font-weight: 500;
    }
    .refresh-btn-pending {
      background: var(--gold) !important;
      border-color: var(--gold) !important;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }
    .line-text {
      font-style: italic;
      max-width: 600px;
      line-height: 1.5;
    }
    .line-text .hit {
      font-style: normal;
      font-weight: 600;
    }
    /* Hide advanced color scale controls for now */
    .color-scale-options { display: none; }
    /* Color legend */
    .legend-wrap { display: inline-flex; gap: 4px; align-items: center; margin-top: 4px; }
    .legend-swatch { width: 26px; height: 14px; border: 1px solid var(--border); border-radius: 2px; display: inline-block; }
    .legend-labels { display: flex; justify-content: space-between; gap: 2rem; font-size: 0.85rem; color: #665544; margin-top: 2px; max-width: 220px; }
    /* Column filter UI */
    th { position: sticky; }
    .filter-icon { font-size: 0.9rem; margin-left: 0.4rem; color: #8a8a8a; cursor: pointer; }
    .filter-icon:hover { color: var(--burgundy); }
    .filter-popover {
      position: absolute;
      z-index: 1000;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 4px 10px var(--shadow);
      padding: 0.6rem;
      min-width: 220px;
    }
    .filter-popover h4 { margin: 0 0 0.4rem 0; font-size: 0.95rem; color: var(--ink); }
    .filter-popover .row { display: flex; gap: 0.5rem; align-items: center; margin: 0.3rem 0; }
    .filter-popover input[type="text"], .filter-popover input[type="number"] { width: 100%; padding: 0.3rem 0.4rem; font-size: 0.95rem; }
    .filter-popover .hint { font-size: 0.8rem; color: #7a6b5b; }
    .filter-popover .actions { display: flex; justify-content: space-between; margin-top: 0.4rem; }
    .filter-popover .link-btn { background: transparent; color: var(--burgundy); border: none; cursor: pointer; padding: 0.2rem 0.3rem; font-size: 0.9rem; }
  </style>
</head>
<body>
  <h1><a href="../">Contabulate</a>: Shakespeare Tabular Search</h1>
  <p class="muted">Search words, bigrams, or trigrams across plays, characters, genres, and more. Use regex (e.g., <code>^love|death$</code>) or plain text. TEI texts courtesy of <a href="https://www.folgerdigitaltexts.org" target="_blank">Folger Digital Texts</a>.</p>

  <div class="tabs" style="display: none;">
    <button class="tab-btn active" data-tab="segments">Rows are Contexts</button>
    <button class="tab-btn" data-tab="ngrams">Rows are Ngrams</button>
    <button class="tab-btn" data-tab="lines">Rows are Lines</button>
  </div>

  <div class="tab-content" id="segmentsTab">
    <div class="controls">
      <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; font-size: 1.05rem;">
        <span style="font-weight: 600;">Show</span>
        <select id="ngramMode" style="font-size: 1rem;">
          <option value="1" selected>single word</option>
          <option value="2">bigram</option>
          <option value="3">trigram</option>
        </select>
        <span style="font-weight: 600;">hits by</span>
        <select id="gran" style="font-size: 1rem;">
          <option value="genre">Genre</option>
          <option value="play">Play</option>
          <option value="act">Act</option>
          <option value="scene" selected>Scene</option>
          <option value="line">Line</option>
          <option value="character">Character</option>
        </select>
        <span style="font-weight: 600;">matching the</span>
        <select id="matchMode" style="font-size: 1rem;">
          <option value="exact">exact term</option>
          <option value="regex">regex pattern</option>
        </select>
        <input id="q" type="text" placeholder="" value="love" style="flex: 1; min-width: 20rem; font-size: 1rem;">
      </div>
      <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; font-size: 0.98rem; margin-top: 0.5rem;">
        <span style="font-weight: 600;">Compare with</span>
        <input id="additionalTermInput" type="text" placeholder="Add another term (e.g., hate)" style="flex: 1; min-width: 14rem; font-size: 0.95rem; padding: 0.45rem 0.6rem;">
        <button id="addTermBtn" type="button" style="padding: 0.45rem 0.8rem;">Add term</button>
      </div>
      <div id="termsList" class="term-chips muted" style="margin-top: 0.35rem; font-size: 0.95rem;">
        No extra terms yet. Add some to see side-by-side columns.
      </div>
    </div>

    <details>
      <summary class="sr"><strong>Display Options</strong></summary>
      <div style="margin-bottom: 0.5rem; display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
        <label><input type="checkbox" class="color-scale-toggle" checked> Color scale numeric columns</label>
        <label><input type="checkbox" class="highlight-toggle" checked> Highlight matching line text</label>
        <label>Term columns:
          <select id="termDisplayMode" style="padding: 0.35rem 0.5rem; font-size: 0.95rem;">
            <option value="both" selected>hits and % (default)</option>
            <option value="counts">hits only</option>
            <option value="pct">% only</option>
          </select>
        </label>
        <button id="downloadSegmentsCsv" class="download-btn" type="button">Download CSV</button>
        <div class="color-scale-options">
          <label>Palette:
            <select class="color-scale-palette">
              <option value="blue-diverging" selected>Gray ↔ Blue (default)</option>
              <option value="blue-linear">Gray ↔ Blue (alt)</option>
              <option value="burgundy-gold">Gold ↔ Burgundy</option>
            </select>
          </label>
          <label>Steps:
            <select class="color-scale-steps">
              <option value="5" selected>5</option>
              <option value="7">7</option>
            </select>
          </label>
        </div>
      </div>
      <div class="color-scale-legend"></div>
      <div class="deep-link-wrap" style="margin-top: .25rem; font-size: 0.95rem;">
        <strong>Deep Link:</strong>
        <a class="deep-link" href="#" target="_blank" rel="noopener" style="word-break: break-all; margin-left: .25rem;"></a>
      </div>
    </details>

    <table id="results">
      <thead><tr id="headRow"></tr></thead>
      <tbody></tbody>
    </table>
    <div id="segmentsFilterActions" style="margin-top: 0.35rem; display: none;">
      <button id="clearSegmentsFilters" class="link-btn" style="padding: 0;">Clear all filters for this view</button>
      <span class="muted" id="segmentsFiltersInfo" style="margin-left: .35rem;"></span>
    </div>
    
    <div class="pagination" id="segmentsPagination" style="display: none;">
      <button id="segmentsFirstPage">First</button>
      <button id="segmentsPrevPage">Prev</button>
      <span class="page-info" id="segmentsPageInfo">Page 1 of 1</span>
      <button id="segmentsNextPage">Next</button>
      <button id="segmentsLastPage">Last</button>
      <label>
        Rows per page:
        <select id="segmentsPageSize">
          <option value="25">25</option>
          <option value="50" selected>50</option>
          <option value="100">100</option>
          <option value="250">250</option>
        </select>
      </label>
      <span class="page-info" id="segmentsTotalInfo"></span>
    </div>
  </div>

  <div class="tab-content" id="ngramsTab" style="display: none;">
    <div class="controls">
      <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; font-size: 1.05rem;">
        <span style="font-weight: 600;">Show</span>
        <select id="ngramsDisplayMode" style="font-size: 1rem;">
          <option value="hits">hits</option>
          <option value="pct">hit %</option>
          <option value="both" selected>hits and hit %</option>
        </select>
        <span style="font-weight: 600;">for</span>
        <select id="ngramsNgramMode" style="font-size: 1rem;">
          <option value="1" selected>single words</option>
          <option value="2">bigrams</option>
          <option value="3">trigrams</option>
        </select>
        <span style="font-weight: 600;">matching the</span>
        <select id="ngramsMatchMode" style="font-size: 1rem;">
          <option value="exact">exact term</option>
          <option value="regex">regex pattern</option>
        </select>
        <input type="text" id="ngramsQuery" placeholder="(optional: leave blank to show all)" style="flex: 1; min-width: 200px; font-size: 1rem; padding: 0.5rem;">
      </div>
    </div>

    <details>
      <summary class="sr"><strong>Select Contexts to Compare</strong></summary>
      <div style="margin-bottom: 0.75rem;">
        <p class="muted" style="margin: 0.5rem 0;">Search for and select plays, acts, scenes, genres, or characters to compare their n-gram frequencies.</p>
        <div style="display: flex; gap: 1rem; margin-top: 0.75rem;">
          <!-- Left column: Search and add contexts -->
          <div style="flex: 1; min-width: 300px;">
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem; align-items: center;">
              <input type="text" id="segmentSearchInput" placeholder="Search segments..." style="flex: 1; padding: 0.5rem;">
              <select id="segmentTypeFilter" style="padding: 0.5rem;">
                <option value="all">All types</option>
                <option value="play">Plays</option>
                <option value="genre">Genres</option>
                <option value="act">Acts</option>
                <option value="scene">Scenes</option>
                <option value="character">Characters</option>
              </select>
            </div>
            <div id="availableSegmentsList" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border); padding: 0.5rem; border-radius: 4px; background: white;">
              <p class="muted" style="text-align: center; padding: 2rem;">Type to search for segments...</p>
            </div>
          </div>
          
          <!-- Right column: Selected contexts -->
          <div style="flex: 1; min-width: 300px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
              <strong>Selected Contexts (<span id="selectedSegmentsCount">0</span>)</strong>
              <button id="clearAllSegments" style="padding: 0.3rem 0.6rem; font-size: 0.9rem;">Clear All</button>
            </div>
            <div id="selectedSegmentsList" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border); padding: 0.5rem; border-radius: 4px; background: white;">
              <p class="muted" style="text-align: center; padding: 2rem;">No contexts selected</p>
            </div>
          </div>
        </div>
      </div>
    </details>

    <div id="ngramTableContainer"></div>
    
    <div class="pagination" id="ngramsPagination" style="display: none;">
      <button id="ngramsFirstPage">First</button>
      <button id="ngramsPrevPage">Prev</button>
      <span class="page-info" id="ngramsPageInfo">Page 1 of 1</span>
      <button id="ngramsNextPage">Next</button>
      <button id="ngramsLastPage">Last</button>
      <label>
        Rows per page:
        <select id="ngramsPageSize">
          <option value="25">25</option>
          <option value="50">50</option>
          <option value="100" selected>100</option>
          <option value="250">250</option>
          <option value="500">500</option>
        </select>
      </label>
      <span class="page-info" id="ngramsTotalInfo"></span>
    </div>
  </div>

  <div class="tab-content" id="linesTab" style="display: none;">
    <div class="controls">
      <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; font-size: 1.05rem;">
        <span style="font-weight: 600;">Show lines with</span>
        <select id="linesNgramMode" style="font-size: 1rem;">
          <option value="1" selected>single word</option>
          <option value="2">bigram</option>
          <option value="3">trigram</option>
        </select>
        <span style="font-weight: 600;">matching the</span>
        <select id="linesMatchMode" style="font-size: 1rem;">
          <option value="exact">exact term</option>
          <option value="regex">regex pattern</option>
        </select>
        <input type="text" id="linesQuery" placeholder="e.g., death, ^love|death$, to be" value="love" style="flex: 1; min-width: 20rem; font-size: 1rem; padding: 0.5rem;">
      </div>
    </div>

    <details>
      <summary class="sr"><strong>Display Options</strong></summary>
      <div style="margin-bottom: 0.5rem; display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
        <label><input type="checkbox" class="color-scale-toggle" checked> Color scale numeric columns</label>
        <label><input type="checkbox" class="highlight-toggle" checked> Highlight matching line text</label>
        <button id="downloadLinesCsv" class="download-btn" type="button">Download CSV</button>
        <div class="color-scale-options">
          <label>Palette:
            <select class="color-scale-palette">
              <option value="blue-diverging" selected>Gray ↔ Blue (default)</option>
              <option value="blue-linear">Gray ↔ Blue (alt)</option>
              <option value="burgundy-gold">Gold ↔ Burgundy</option>
            </select>
          </label>
          <label>Steps:
            <select class="color-scale-steps">
              <option value="5" selected>5</option>
              <option value="7">7</option>
            </select>
          </label>
        </div>
      </div>
      <div class="color-scale-legend"></div>
      <div class="deep-link-wrap" style="margin-top: .25rem; font-size: 0.95rem;">
        <strong>Deep Link:</strong>
        <a class="deep-link" href="#" target="_blank" rel="noopener" style="word-break: break-all; margin-left: .25rem;"></a>
      </div>
    </details>

    <table id="linesResults">
      <thead><tr id="linesHeadRow"></tr></thead>
      <tbody id="linesTableBody"></tbody>
    </table>
    <div id="linesFilterActions" style="margin-top: 0.35rem; display: none;">
      <button id="clearLinesFilters" class="link-btn" style="padding: 0;">Clear all filters for this view</button>
      <span class="muted" id="linesFiltersInfo" style="margin-left: .35rem;"></span>
    </div>

    <div class="pagination" id="linesPagination" style="display: none;">
      <button id="linesFirstPage">First</button>
      <button id="linesPrevPage">Prev</button>
      <span class="page-info" id="linesPageInfo">Page 1 of 1</span>
      <button id="linesNextPage">Next</button>
      <button id="linesLastPage">Last</button>
      <label>
        Rows per page:
        <select id="linesPageSize">
          <option value="25">25</option>
          <option value="50" selected>50</option>
          <option value="100">100</option>
          <option value="250">250</option>
        </select>
      </label>
      <span class="page-info" id="linesTotalInfo"></span>
    </div>
  </div>

<script>
(async function() {
  const q = document.getElementById('q');
  const gran = document.getElementById('gran');
  const go = document.getElementById('go');
  const matchMode = document.getElementById('matchMode');
  const ngramMode = document.getElementById('ngramMode');
  const theadRow = document.getElementById('headRow');
  const tbody = document.querySelector('#results tbody');
  const ngramTableContainer = document.getElementById('ngramTableContainer');
  const termDisplayModeSel = document.getElementById('termDisplayMode');
  const addTermInput = document.getElementById('additionalTermInput');
  const addTermBtn = document.getElementById('addTermBtn');
  const termsList = document.getElementById('termsList');
  let extraTerms = [];
  let termDisplayMode = 'both';
  
  // Color scale toggle state (global across tabs)
  let colorScaleEnabled = true;
  // Highlight toggle state (global across tabs)
  let highlightEnabled = true;
  let colorScalePalette = 'blue-diverging';
  let colorScaleSteps = 7;
  function syncColorScaleToggles() {
    document.querySelectorAll('.color-scale-toggle').forEach(cb => {
      if (cb) cb.checked = colorScaleEnabled;
    });
  }
  function syncColorScaleOptions() {
    document.querySelectorAll('.color-scale-palette').forEach(sel => {
      if (sel) sel.value = colorScalePalette;
    });
    document.querySelectorAll('.color-scale-steps').forEach(sel => {
      if (sel) sel.value = String(colorScaleSteps);
    });
  }
  function setColorScaleEnabled(v) {
    colorScaleEnabled = !!v;
    syncColorScaleToggles();
    // Re-apply on currently rendered tables
    applyColorScalesForVisibleTables();
  }
  function syncHighlightToggles() {
    document.querySelectorAll('.highlight-toggle').forEach(cb => { if (cb) cb.checked = highlightEnabled; });
  }
  function setHighlightEnabled(v) {
    highlightEnabled = !!v;
    syncHighlightToggles();
    // Rebuild views so highlighting updates
    const segQ = q.value.trim();
    if (segQ) doSearch();
    const linesQ = document.getElementById('linesQuery').value.trim();
    if (linesQ) doLinesSearch();
  }
  function normalizeTerm(term) {
    return String(term || '').toLowerCase().replace(/\s+/g, ' ').trim();
  }
  function pruneExtraTermsAgainstPrimary() {
    const primaryNorm = normalizeTerm(q.value || '');
    const filtered = extraTerms.filter(t => normalizeTerm(t) !== primaryNorm);
    if (filtered.length !== extraTerms.length) {
      extraTerms = filtered;
      renderExtraTerms();
    }
  }
  function getActiveTerms() {
    const seen = new Set();
    const out = [];
    const add = (term) => {
      const norm = normalizeTerm(term);
      if (!norm || seen.has(norm)) return;
      seen.add(norm);
      out.push(term.trim());
    };
    add(q.value || '');
    extraTerms.forEach(add);
    return out;
  }
  function renderExtraTerms() {
    if (!termsList) return;
    const terms = extraTerms.filter(t => t && t.trim());
    if (terms.length === 0) {
      termsList.classList.add('muted');
      termsList.textContent = 'No extra terms yet. Add some to see side-by-side columns.';
      return;
    }
    termsList.classList.remove('muted');
    termsList.innerHTML = '';
    terms.forEach((term, idx) => {
      const pill = document.createElement('span');
      pill.className = 'term-pill';
      pill.innerHTML = `<span>${escapeHTML(term)}</span><button type="button" class="remove-term" data-idx="${idx}" aria-label="Remove term ${escapeHTML(term)}">×</button>`;
      termsList.appendChild(pill);
    });
    termsList.querySelectorAll('.remove-term').forEach(btn => {
      btn.addEventListener('click', () => {
        const i = parseInt(btn.dataset.idx, 10);
        if (!Number.isNaN(i)) {
          extraTerms.splice(i, 1);
          renderExtraTerms();
          checkSegmentsPendingChanges();
          doSearch();
        }
      });
    });
  }
  function addExtraTerm(term) {
    const val = (term ?? '').trim();
    if (!val) return;
    const normVal = normalizeTerm(val);
    const primaryNorm = normalizeTerm(q.value || '');
    if (normVal === primaryNorm) return;
    const existing = extraTerms.map(normalizeTerm);
    if (existing.includes(normVal)) return;
    extraTerms.push(val);
    renderExtraTerms();
    checkSegmentsPendingChanges();
    doSearch();
  }
  function parseNumeric(text) {
    if (text == null) return NaN;
    const raw = String(text).trim();
    if (!raw) return NaN;
    const s = raw.replace(/,/g, '');
    // Strict numeric: optional sign, digits with optional decimal OR leading decimal, optional trailing %.
    // Entire cell must match; avoids treating values like "3H6" as numeric.
    const re = /^-?(?:\d+(?:\.\d+)?|\.\d+)%?$/;
    if (!re.test(s)) return NaN;
    const num = parseFloat(s.replace('%',''));
    return Number.isFinite(num) ? num : NaN;
  }
  function clearColorScale(table) {
    if (!table) return;
    table.querySelectorAll('tbody td').forEach(td => {
      td.style.background = '';
      td.style.backgroundColor = '';
      td.style.color = '';
    });
  }
  // choose text color for contrast with bg
  function pickTextColorForBg(rgbStr) {
    const m = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(rgbStr);
    if (!m) return '#1a1a1a';
    const r = parseInt(m[1],10), g = parseInt(m[2],10), b = parseInt(m[3],10);
    const brightness = (r*299 + g*587 + b*114) / 1000; // YIQ
    return brightness < 170 ? '#ffffff' : '#1a1a1a';
  }
  function quantiles(arr, qs) {
    if (!arr.length) return qs.map(() => NaN);
    const a = [...arr].sort((x,y)=>x-y);
    const n = a.length;
    return qs.map(q => {
      if (n === 1) return a[0];
      const pos = (n - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      return a[base] + (a[Math.min(base+1, n-1)] - a[base]) * rest;
    });
  }
  function applyColorScale(table) {
    if (!table) return;
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    if (rows.length === 0) return;
    const colCount = (rows[0]?.children?.length) || 0;
    const palette = getPalette(colorScalePalette, colorScaleSteps);
    // For each column, compute min/max of numeric cells
    for (let c = 0; c < colCount; c++) {
      const colTds = rows.map(r => r.children[c]).filter(Boolean);
      const values = [];
      const cells = [];
      for (const td of colTds) {
        // Prefer data-value if present
        const dv = td.getAttribute('data-value');
        const v = dv != null ? parseFloat(dv) : parseNumeric(td.textContent);
        if (Number.isFinite(v)) {
          values.push(v);
          cells.push([td, v]);
        }
      }
      if (values.length < 2) continue; // not a numeric column
      const min = Math.min(...values);
      const max = Math.max(...values);
      if (!(max > min)) continue; // no spread

      // Compute quantile thresholds based on selected steps
      const thresholds = [];
      for (let i = 1; i < palette.length; i++) {
        thresholds.push(i / palette.length);
      }
      const qs = quantiles(values, thresholds);
      for (const [td, v] of cells) {
        let idx = 0;
        while (idx < qs.length && v > qs[idx]) idx++;
        const bg = palette[idx];
        td.style.backgroundColor = bg;
        td.style.color = pickTextColorForBg(bg);
      }
    }
  }
  function applyOrClear(tableSel) {
    const table = document.querySelector(tableSel);
    if (!table) return;
    if (colorScaleEnabled) applyColorScale(table); else clearColorScale(table);
  }
  function applyColorScalesForVisibleTables() {
    applyOrClear('#results');
    applyOrClear('#ngramsTable');
    applyOrClear('#linesResults');
    renderAllLegends();
  }
  // Sort state defaults (declare before deep-link logic uses them)
  let sortKey = null, sortDir = 'desc';
  let linesSortKey = 'line_num', linesSortDir = 'asc';
  // Column filters maps (declare early for deep-link)
  // Scope segments filters by current granularity (play/genre/act/scene/line/character)
  const segmentsFiltersByGran = new Map(); // gran -> Map(columnKey -> filter)
  function getSegmentsFiltersMap() {
    const g = (typeof gran !== 'undefined' && gran && gran.value) ? gran.value : 'scene';
    if (!segmentsFiltersByGran.has(g)) segmentsFiltersByGran.set(g, new Map());
    return segmentsFiltersByGran.get(g);
  }
  const linesColumnFilters = new Map();
  // Segments pagination and rows (declare early for deep-link)
  let segmentsCurrentPage = 1;
  let segmentsPageSize = 50;
  let segmentsAllRows = [];
  let lastSegmentsBaseRows = [];
  // Deep link: human-readable query params (fallback to legacy base64 `state`)
  function buildQueryParamsFromState() {
    const p = new URLSearchParams();
    // Only segments are supported for deep links currently
    // Display
    p.set('cs', colorScaleEnabled ? '1' : '0');
    p.set('td', termDisplayMode);
    // palette and steps omitted for cleaner URLs
    p.set('hl', highlightEnabled ? '1' : '0');
    // Segments
    p.set('q', q.value.trim());
    p.set('nm', ngramMode.value);
    p.set('gran', gran.value);
    p.set('mm', matchMode.value);
    const extras = extraTerms.map(t => t.trim()).filter(Boolean);
    if (extras.length) {
      try {
        p.set('qt', encodeURIComponent(JSON.stringify(extras)));
      } catch (e) {
        // fallback to legacy join if JSON stringify fails (shouldn't)
        p.set('qt', extras.join('|'));
      }
    }
    if (sortKey) p.set('sk', sortKey);
    if (sortDir) p.set('sd', sortDir);
    // Segment column filters (only for current granularity)
    const segFilters = getSegmentsFiltersMap();
    for (const [key, v] of segFilters.entries()) {
      if (v.type === 'number') {
        const min = (v.min ?? '');
        const max = (v.max ?? '');
        p.set('s_fn_' + key, `${min}~${max}`);
      } else if (v.type === 'text') {
        p.set('s_ft_' + key, v.pattern ?? '');
      }
    }
    return p;
  }
  function getActiveTab() {
    const btn = document.querySelector('.tab-btn.active');
    return btn ? btn.dataset.tab : 'segments';
  }
  let appliedDeepLinkState = false;
  function mapToArray(m) {
    const out = [];
    if (!m) return out;
    for (const [key, v] of m.entries()) {
      const o = { key, type: v.type };
      if (v.type === 'number') { o.min = v.min ?? ''; o.max = v.max ?? ''; }
      if (v.type === 'text') { o.pattern = v.pattern ?? ''; }
      out.push(o);
    }
    return out;
  }
  // Legacy base64 state decoder for backward compatibility
  function decodeState(s) {
    try {
      const b64 = (s || '').replace(/ /g, '+');
      return JSON.parse(decodeURIComponent(escape(atob(b64))));
    } catch(e) { return null; }
  }
  function decodeExtrasParam(raw) {
    if (!raw) return [];
    // New format: URL-encoded JSON array
    try {
      const decoded = decodeURIComponent(raw);
      const arr = JSON.parse(decoded);
      if (Array.isArray(arr)) return arr;
    } catch(e) { /* fall through to legacy */ }
    // Legacy: pipe-separated string
    return raw.split('|').map(t => t.trim()).filter(Boolean);
  }
  function arrayToMap(arr) {
    const m = new Map();
    if (!Array.isArray(arr)) return m;
    for (const it of arr) {
      if (!it || !it.key) continue;
      if (it.type === 'number') m.set(it.key, { type:'number', min: it.min ?? '', max: it.max ?? '' });
      else if (it.type === 'text') m.set(it.key, { type:'text', pattern: it.pattern ?? '' });
    }
    return m;
  }
  function updateDeepLink() {
    const p = buildQueryParamsFromState();
    const url = location.origin + location.pathname + '?' + p.toString();
    document.querySelectorAll('.deep-link').forEach(a => { a.href = url; a.textContent = url; });
  }
  function updateSegmentsFilterActions() {
    const container = document.getElementById('segmentsFilterActions');
    if (!container) return;
    const count = getSegmentsFiltersMap().size;
    if (count > 0) {
      container.style.display = 'block';
      const info = document.getElementById('segmentsFiltersInfo');
      if (info) info.textContent = `(${count} active filter${count>1?'s':''})`;
    } else {
      container.style.display = 'none';
    }
  }
  function getPalette(name, steps) {
    steps = parseInt(steps) || 5;
    const clampSteps = (arr) => {
      if (arr.length === steps) return arr;
      // simple resampling by index
      const out = [];
      for (let i = 0; i < steps; i++) {
        const idx = Math.round(i * (arr.length - 1) / (steps - 1));
        out.push(arr[idx]);
      }
      return out;
    };
    if (name === 'blue-diverging') {
      // Ensure white at center and darkest gray at the low end
      const base5 = ['rgb(176, 176, 176)','rgb(209, 209, 209)','rgb(250, 250, 250)','rgb(134, 164, 177)','rgb(0, 63, 92)'];
      const base7 = ['rgb(180,180,180)','rgb(200,200,200)','rgb(220,220,220)','rgb(250,250,250)','rgb(150,175,185)','rgb(110,140,160)','rgb(0,63,92)'];
      return clampSteps(steps === 7 ? base7 : base5);
    } else if (name === 'blue-linear') {
      // Convert to diverging with white center and dark extremes
      const base5 = ['rgb(120,120,120)','rgb(176,176,176)','rgb(250,250,250)','rgb(134,164,177)','rgb(0,63,92)'];
      const base7 = ['rgb(110,110,110)','rgb(150,150,150)','rgb(190,190,190)','rgb(250,250,250)','rgb(160,180,190)','rgb(110,140,160)','rgb(0,63,92)'];
      return clampSteps(steps === 7 ? base7 : base5);
    } else if (name === 'burgundy-gold') {
      // Diverging: dark earthy gold -> white -> dark burgundy
      const base5 = ['rgb(120,100,40)','rgb(190,170,90)','rgb(250,250,250)','rgb(170,110,120)','rgb(139,21,56)'];
      const base7 = ['rgb(110,90,35)','rgb(150,130,60)','rgb(200,180,100)','rgb(250,250,250)','rgb(185,130,135)','rgb(160,90,110)','rgb(139,21,56)'];
      return clampSteps(steps === 7 ? base7 : base5);
    }
    return getPalette('blue-diverging', steps);
  }
  function renderLegend(container, palette) {
    if (!container) return;
    container.innerHTML = '';
    const wrap = document.createElement('div');
    wrap.className = 'legend-wrap';
    palette.forEach((c, i) => {
      const sw = document.createElement('span');
      sw.className = 'legend-swatch';
      sw.style.backgroundColor = c;
      sw.title = i === 0 ? 'Low' : (i === palette.length - 1 ? 'High' : (palette.length % 2 === 1 && i === Math.floor(palette.length/2) ? 'Median' : ''));
      wrap.appendChild(sw);
    });
    const labels = document.createElement('div');
    labels.className = 'legend-labels';
    labels.innerHTML = '<span>Low</span><span>Median</span><span>High</span>';
    container.appendChild(wrap);
    container.appendChild(labels);
  }
  function renderAllLegends() {
    const pal = getPalette(colorScalePalette, colorScaleSteps);
    document.querySelectorAll('.color-scale-legend').forEach(el => renderLegend(el, pal));
  }
  if (termDisplayModeSel) termDisplayModeSel.value = termDisplayMode;

  // Pending changes tracking
  let segmentsPendingChanges = false;
  let ngramsPendingChanges = false;
  
  // Last search state for segments
  let lastSegmentsState = {
    query: '',
    ngramMode: '',
    gran: '',
    matchMode: '',
    termDisplayMode: 'both',
    extraTerms: []
  };
  
  // Last search state for ngrams
  let lastNgramsState = {
    query: '',
    ngramMode: '',
    matchMode: '',
    displayMode: '',
    segments: new Set()
  };

  // Tab switching
  const tabBtns = document.querySelectorAll('.tab-btn');
  const segmentsTab = document.getElementById('segmentsTab');
  const ngramsTab = document.getElementById('ngramsTab');
  const linesTab = document.getElementById('linesTab');
  
  tabBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const targetTab = btn.dataset.tab;
      tabBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      segmentsTab.style.display = 'none';
      ngramsTab.style.display = 'none';
      linesTab.style.display = 'none';
      
      if (targetTab === 'segments') {
        segmentsTab.style.display = 'block';
      } else if (targetTab === 'ngrams') {
        ngramsTab.style.display = 'block';
      } else if (targetTab === 'lines') {
        linesTab.style.display = 'block';
      }
      updateDeepLink();
    });
  });

  async function loadJSON(path) {
    const res = await fetch(path);
    if (!res.ok) throw new Error(`Failed to load ${path}: ${res.status}`);
    return res.json();
  }

  let chunks=[], tokens={}, tokens2={}, tokens3={}, plays=[], characters=[], tokensChar={}, tokensChar2={}, tokensChar3={}, allLines=[];
  try {
    [chunks, tokens, tokens2, tokens3, plays, characters, tokensChar, tokensChar2, tokensChar3] = await Promise.all([
      loadJSON('data/chunks.json'),
      loadJSON('data/tokens.json'),
      loadJSON('data/tokens2.json'),
      loadJSON('data/tokens3.json'),
      loadJSON('data/plays.json'),
      loadJSON('data/characters.json'),
      loadJSON('data/tokens_char.json'),
      loadJSON('data/tokens_char2.json'),
      loadJSON('data/tokens_char3.json'),
    ]);
  } catch(e) {
    console.error('Failed to load data:', e);
    return;
  }


  // Load line data
  try {
    allLines = await loadJSON('lines/all_lines.json');
  } catch(e) {
    console.warn('Lines data not available:', e);
  }

  const chunkById = new Map(chunks.map(r => [r.scene_id, r]));
  const playsById = new Map(plays.map(p => [p.play_id, p]));
  const charactersById = new Map(characters.map(c => [c.character_id, c]));

  // Name normalization util used elsewhere
  function normName(s){ return String(s||'').toUpperCase().replace(/\s+/g,' ').trim(); }

  // Ngrams tab state
  let ngramsSelectedSegments = new Set();
  
  // Removed play checkbox filter (use column regex filters instead)
  
  // Build all available segments list
  let allAvailableSegments = [];
  
  function buildAvailableSegments() {
    allAvailableSegments = [];
    
    // Add plays
    plays.forEach(p => {
      allAvailableSegments.push({
        type: 'play',
        id: p.play_id,
        label: p.title,
        meta: `${p.genre || 'Unknown'}, ${p.first_performance_year || 'Unknown year'}`,
        searchText: `${p.title} ${p.genre || ''} play`.toLowerCase()
      });
    });
    
    // Add genres
    const genres = [...new Set(plays.map(p => p.genre).filter(Boolean))];
    genres.forEach(g => {
      allAvailableSegments.push({
        type: 'genre',
        id: g,
        label: g,
        meta: `Genre`,
        searchText: `${g} genre`.toLowerCase()
      });
    });
    
    // Add acts
    const acts = new Map();
    chunks.forEach(chunk => {
      const key = `${chunk.play_id}:${chunk.act}`;
      if (!acts.has(key)) {
        const play = playsById.get(chunk.play_id);
        acts.set(key, {
          type: 'act',
          id: key,
          label: `${play.title} - Act ${chunk.act}`,
          meta: `Act`,
          searchText: `${play.title} act ${chunk.act}`.toLowerCase()
        });
      }
    });
    allAvailableSegments.push(...acts.values());
    
    // Add scenes
    chunks.forEach(chunk => {
      const play = playsById.get(chunk.play_id);
      allAvailableSegments.push({
        type: 'scene',
        id: chunk.scene_id,
        label: `${play.title} - Act ${chunk.act}, Scene ${chunk.scene}`,
        meta: `${chunk.total_words || 0} words`,
        searchText: `${play.title} act ${chunk.act} scene ${chunk.scene}`.toLowerCase()
      });
    });
    
    // Add all characters (sorted by word count)
    const sortedChars = [...characters].sort((a, b) => (b.total_words_spoken || 0) - (a.total_words_spoken || 0));
    sortedChars.forEach(c => {
      allAvailableSegments.push({
        type: 'character',
        id: c.character_id,
        label: `${c.name} (${c.play_title})`,
        meta: `${c.total_words_spoken || 0} words`,
        searchText: `${c.name} ${c.play_title} character`.toLowerCase()
      });
    });
  }
  
  buildAvailableSegments();
  renderExtraTerms();
  
  // Render available segments based on search
  function renderAvailableSegments() {
    const searchInput = document.getElementById('segmentSearchInput');
    const typeFilter = document.getElementById('segmentTypeFilter');
    const container = document.getElementById('availableSegmentsList');
    
    const searchTerm = searchInput.value.toLowerCase().trim();
    const typeValue = typeFilter.value;
    
    // Filter segments
    let filtered = allAvailableSegments.filter(seg => {
      // Type filter
      if (typeValue !== 'all' && seg.type !== typeValue) return false;
      
      // Search filter
      if (searchTerm && !seg.searchText.includes(searchTerm)) return false;
      
      // Don't show already selected segments
      const isSelected = Array.from(ngramsSelectedSegments).some(selected => 
        selected.type === seg.type && String(selected.id) === String(seg.id)
      );
      if (isSelected) return false;
      
      return true;
    });
    
    // Limit to 100 results for performance
    if (filtered.length > 100) {
      filtered = filtered.slice(0, 100);
    }
    
    if (filtered.length === 0) {
      container.innerHTML = '<p class="muted" style="text-align: center; padding: 2rem;">No segments found</p>';
      return;
    }
    
    container.innerHTML = '';
    filtered.forEach(seg => {
      const div = document.createElement('div');
      div.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 0.4rem; margin-bottom: 0.25rem; border-bottom: 1px solid var(--border);';
      
      const typeLabel = seg.type.charAt(0).toUpperCase() + seg.type.slice(1);
      div.innerHTML = `
        <div style="flex: 1; min-width: 0;">
          <div style="font-weight: 500;">${seg.label}</div>
          <div class="muted" style="font-size: 0.85rem;">${seg.meta}</div>
        </div>
        <button class="add-segment-btn" data-type="${seg.type}" data-id="${seg.id}" data-label="${seg.label}" style="padding: 0.25rem 0.6rem; font-size: 0.85rem; white-space: nowrap;">Add</button>
      `;
      container.appendChild(div);
    });
    
    // Add click handlers
    container.querySelectorAll('.add-segment-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const segType = btn.dataset.type;
        let segId = btn.dataset.id;
        
        // Parse numeric IDs for appropriate types
        if (segType === 'play' || segType === 'character' || segType === 'scene') {
          segId = parseInt(segId);
        }
        
        ngramsSelectedSegments.add({
          type: segType,
          id: segId,
          label: btn.dataset.label
        });
        
        renderAvailableSegments();
        renderSelectedSegments();
        checkNgramsPendingChanges();
      });
    });
  }
  
  // Render selected segments
  function renderSelectedSegments() {
    const container = document.getElementById('selectedSegmentsList');
    const countSpan = document.getElementById('selectedSegmentsCount');
    
    countSpan.textContent = ngramsSelectedSegments.size;
    
    if (ngramsSelectedSegments.size === 0) {
      container.innerHTML = '<p class="muted" style="text-align: center; padding: 2rem;">No segments selected</p>';
      return;
    }
    
    container.innerHTML = '';
    const sortedSegments = Array.from(ngramsSelectedSegments).sort((a, b) => a.label.localeCompare(b.label));
    
    sortedSegments.forEach(seg => {
      const div = document.createElement('div');
      div.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 0.4rem; margin-bottom: 0.25rem; border-bottom: 1px solid var(--border);';
      
      const typeLabel = seg.type.charAt(0).toUpperCase() + seg.type.slice(1);
      div.innerHTML = `
        <div style="flex: 1; min-width: 0;">
          <div style="font-weight: 500;">${seg.label}</div>
          <div class="muted" style="font-size: 0.85rem;">${typeLabel}</div>
        </div>
        <button class="remove-segment-btn" style="padding: 0.25rem 0.6rem; font-size: 0.85rem; background: #dc3545; border-color: #dc3545;">Remove</button>
      `;
      container.appendChild(div);
      
      // Add remove handler
      div.querySelector('.remove-segment-btn').addEventListener('click', () => {
        ngramsSelectedSegments.delete(seg);
        renderAvailableSegments();
        renderSelectedSegments();
        checkNgramsPendingChanges();
      });
    });
  }
  
  // Initialize segment selectors
  function initSegmentSelectors() {
    const searchInput = document.getElementById('segmentSearchInput');
    const typeFilter = document.getElementById('segmentTypeFilter');
    const clearAllBtn = document.getElementById('clearAllSegments');
    
    searchInput.addEventListener('input', renderAvailableSegments);
    typeFilter.addEventListener('change', renderAvailableSegments);
    
    clearAllBtn.addEventListener('click', () => {
      ngramsSelectedSegments.clear();
      renderAvailableSegments();
      renderSelectedSegments();
      checkNgramsPendingChanges();
    });
    
    // Initial render
    renderSelectedSegments();
  }
  
  initSegmentSelectors();
  // Apply state from deep link if present
  (function applyStateFromURL(){
    const sp = new URLSearchParams(location.search);
    // New readable params first
    if (sp.has('tab') || sp.has('q') || sp.has('l_q')) {
      appliedDeepLinkState = true;
      try {
        // Display
        if (sp.has('cs')) colorScaleEnabled = sp.get('cs') === '1';
        // ignore palette and steps from URL to keep behavior consistent and URLs clean
        if (sp.has('hl')) highlightEnabled = sp.get('hl') === '1';
        syncColorScaleToggles(); syncColorScaleOptions(); syncHighlightToggles();
        // Tab (ignored; segments only)
        // Segments
        if (sp.has('q')) q.value = sp.get('q');
        if (sp.has('nm')) ngramMode.value = sp.get('nm');
        if (sp.has('gran')) gran.value = sp.get('gran');
        if (sp.has('mm')) matchMode.value = sp.get('mm');
        if (sp.has('td')) {
          termDisplayMode = sp.get('td');
          if (termDisplayModeSel) termDisplayModeSel.value = termDisplayMode;
        }
        if (sp.has('qt')) {
          extraTerms = decodeExtrasParam(sp.get('qt'));
          pruneExtraTermsAgainstPrimary();
          renderExtraTerms();
        }
        if (sp.has('sk')) sortKey = sp.get('sk');
        if (sp.has('sd')) sortDir = sp.get('sd');
        // Clear filters only for current granularity
        getSegmentsFiltersMap().clear();
        for (const [k, v] of sp.entries()) {
          if (k.startsWith('s_fn_')) {
            const key = k.slice(5);
            const [min, max] = (v || '').split('~');
            getSegmentsFiltersMap().set(key, { type:'number', min, max });
          } else if (k.startsWith('s_ft_')) {
            const key = k.slice(5);
            getSegmentsFiltersMap().set(key, { type:'text', pattern: v || '' });
          }
        }
      } catch(e) { /* continue to finally */ }
      // Trigger render for segments regardless
      const qv = q.value.trim(); if (qv) doSearch();
      applyColorScalesForVisibleTables();
      updateDeepLink();
      return;
    }
    // Legacy base64 fallback
    const enc = sp.get('state');
    if (!enc) { updateDeepLink(); return; }
    const st = decodeState(enc);
    if (!st) { updateDeepLink(); return; }
    try {
      // Display
      if (st.display) {
        if (typeof st.display.colorScaleEnabled === 'boolean') colorScaleEnabled = st.display.colorScaleEnabled;
        if (st.display.colorScalePalette) colorScalePalette = st.display.colorScalePalette;
        if (st.display.colorScaleSteps) colorScaleSteps = st.display.colorScaleSteps;
        if (typeof st.display.highlightEnabled === 'boolean') highlightEnabled = st.display.highlightEnabled;
        syncColorScaleToggles(); syncColorScaleOptions(); syncHighlightToggles();
      }
      // Tab
      if (st.tab) {
        const btn = document.querySelector(`.tab-btn[data-tab="${st.tab}"]`);
        if (btn) btn.click();
      }
      // Segments
      if (st.segments) {
      if (st.segments.q != null) q.value = st.segments.q;
      if (st.segments.ngramMode) ngramMode.value = st.segments.ngramMode;
      if (st.segments.gran) gran.value = st.segments.gran;
      if (st.segments.matchMode) matchMode.value = st.segments.matchMode;
      if (st.segments.termDisplayMode) {
        termDisplayMode = st.segments.termDisplayMode;
        if (termDisplayModeSel) termDisplayModeSel.value = termDisplayMode;
      }
      if (Array.isArray(st.segments.extraTerms)) {
        extraTerms = st.segments.extraTerms.filter(Boolean);
        pruneExtraTermsAgainstPrimary();
        renderExtraTerms();
      }
        if (st.segments.sortKey) sortKey = st.segments.sortKey;
        if (st.segments.sortDir) sortDir = st.segments.sortDir;
        // Clear and set filters only for current granularity
        getSegmentsFiltersMap().clear();
        if (st.segments.filters) {
          const m = arrayToMap(st.segments.filters);
          for (const [k,v] of m.entries()) getSegmentsFiltersMap().set(k,v);
        }
      }
      // Lines
      if (st.lines) {
        const lq = document.getElementById('linesQuery');
        if (st.lines.q != null) lq.value = st.lines.q;
        const ln = document.getElementById('linesNgramMode');
        if (st.lines.ngramMode) ln.value = st.lines.ngramMode;
        const lm = document.getElementById('linesMatchMode');
        if (st.lines.matchMode) lm.value = st.lines.matchMode;
        if (st.lines.sortKey) linesSortKey = st.lines.sortKey;
        if (st.lines.sortDir) linesSortDir = st.lines.sortDir;
        linesColumnFilters.clear();
        if (st.lines.filters) {
          const m2 = arrayToMap(st.lines.filters);
          for (const [k,v] of m2.entries()) linesColumnFilters.set(k,v);
        }
      }
      // Trigger renders
      const qv = q.value.trim(); if (qv) doSearch();
      const lqv = document.getElementById('linesQuery').value.trim(); if (lqv) doLinesSearch();
      applyColorScalesForVisibleTables();
      appliedDeepLinkState = true;
    } catch(e) { /* ignore */ }
    updateDeepLink();
  })();
  
  // No selectedPlayIds — include all plays; use header filters to refine
  function fmtPct(num) { return (num*100).toFixed(3) + '%'; }
  function escapeHTML(s) {
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  }
  function highlightHTML(text, re) {
    if (!re) return escapeHTML(text);
    let out = '';
    let last = 0;
    const s = String(text);
    re.lastIndex = 0;
    let m;
    while ((m = re.exec(s))) {
      const start = m.index;
      const end = start + (m[0]?.length || 0);
      out += escapeHTML(s.slice(last, start));
      out += '<span class="hit">' + escapeHTML(m[0]) + '</span>';
      last = end;
      if (!re.global) break;
      if (end === start) re.lastIndex++; // avoid zero-width infinite loop
    }
    out += escapeHTML(s.slice(last));
    return out;
  }
  function toCsvValue(val) {
    const s = String(val ?? '');
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  }
  function downloadCsv(filename, rows) {
    const csv = rows.map(r => r.map(toCsvValue).join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  function downloadTableCsv(tableSelector, filename) {
    const table = document.querySelector(tableSelector);
    if (!table) return;
    const rows = [];
    const thead = table.querySelector('thead');
    if (thead) {
      const headRow = [];
      thead.querySelectorAll('th').forEach(th => {
        const label = th.childNodes[0]?.textContent || th.textContent || '';
        headRow.push(label.replace('⚙','').trim());
      });
      if (headRow.length) rows.push(headRow);
    }
    table.querySelectorAll('tbody tr').forEach(tr => {
      const row = [];
      tr.querySelectorAll('td').forEach(td => {
        row.push(td.textContent.trim());
      });
      rows.push(row);
    });
    if (rows.length <= 1) return;
    downloadCsv(filename, rows);
  }
  function countRegexMatches(text, re) {
    if (!re) return 0;
    const flags = re.flags.includes('g') ? re.flags : re.flags + 'g';
    const r = new RegExp(re.source, flags);
    let count = 0;
    let m;
    while ((m = r.exec(text))) {
      if (m[0].length === 0) {
        r.lastIndex++;
        continue;
      }
      count++;
    }
    return count;
  }

  // Simple debounce helper for responsive UI without spamming renders
  function debounce(fn, wait = 250) {
    let t;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), wait);
    };
  }


  // Pagination state (segments vars declared earlier to support deep-link init)
  let ngramsCurrentPage = 1;
  let ngramsPageSize = 100;
  let ngramsAllRows = [];

  // Pagination helper
  function paginateArray(arr, page, pageSize) {
    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    return arr.slice(start, end);
  }

  function getTotalPages(totalRows, pageSize) {
    return Math.max(1, Math.ceil(totalRows / pageSize));
  }

  const actTotals = new Map();
  const playTotals = new Map();
  for (const r of chunks) {
    const k = `${r.play_id}:${r.act}`;
    actTotals.set(k, (actTotals.get(k)||0) + (r.total_words||0));
    playTotals.set(r.play_id, (playTotals.get(r.play_id)||0) + (r.total_words||0));
  }

  
  let ngramsSortKey = 'totalCount', ngramsSortDir = 'desc';
  // Column filters state (moved earlier)
  
  function setHeaders(cols){
    theadRow.innerHTML='';
    cols.forEach(c => {
      const th = document.createElement('th');
      th.textContent = c.label;
      th.dataset.key = c.key;
      th.dataset.type = c.type || 'text';
      th.title = 'Click to sort';
      th.addEventListener('click', () => {
        if (sortKey === c.key) sortDir = (sortDir === 'asc' ? 'desc' : 'asc');
        else { sortKey = c.key; sortDir = c.defaultDir || 'desc'; }
        segmentsAllRows = sortRows(segmentsAllRows);
        segmentsCurrentPage = 1;
        renderSegmentsPage();
      });
      // Add filter icon
      const icon = document.createElement('span');
      icon.className = 'filter-icon';
      icon.textContent = '⚙';
      icon.title = 'Filter this column';
      icon.addEventListener('click', (e) => {
        e.stopPropagation();
        showFilterPopover(th, c.key, (c.type||'text'), 'segments');
      });
      th.appendChild(icon);
      theadRow.appendChild(th);
    });
    updateSortIndicators();
  }
  
  function updateSortIndicators(){
    theadRow.querySelectorAll('th').forEach(th => {
      th.classList.remove('sorted-asc', 'sorted-desc');
      if (th.dataset.key === sortKey) {
        th.classList.add(sortDir === 'asc' ? 'sorted-asc' : 'sorted-desc');
      }
    });
  }
  function sortRows(rows){
    if (!sortKey) return rows;
    const parseIdParts = (id) => {
      const s = String(id || '');
      const parts = s.split('.');
      const abbr = parts[0] || '';
      const act = parts.length > 1 ? parseInt(parts[1], 10) || 0 : 0;
      const scene = parts.length > 2 ? parseInt(parts[2], 10) || 0 : 0;
      const line = parts.length > 3 ? parseInt(parts[3], 10) || 0 : 0;
      return { abbr, act, scene, line };
    };
    rows.sort((a,b) => {
      const av = a[sortKey], bv = b[sortKey];
      if (sortKey === 'id') {
        const aa = parseIdParts(av);
        const bb = parseIdParts(bv);
        let cmp = aa.abbr.localeCompare(bb.abbr);
        if (cmp === 0) cmp = aa.act - bb.act;
        if (cmp === 0) cmp = aa.scene - bb.scene;
        if (cmp === 0) cmp = aa.line - bb.line;
        return sortDir === 'asc' ? cmp : -cmp;
      }
      if (typeof av === 'string' || typeof bv === 'string') {
        return sortDir === 'asc' ? String(av).localeCompare(String(bv)) : String(bv).localeCompare(String(av));
      }
      return sortDir === 'asc' ? (av - bv) : (bv - av);
    });
    return rows;
  }

  function denomFor(n, levelKey, meta){
    const tw = (levelKey==='scene') ? (meta.total_words||0)
               : (levelKey==='act') ? (actTotals.get(`${meta.play_id}:${meta.act}`)||0)
               : (levelKey==='play') ? (playTotals.get(meta.play_id)||0)
               : (levelKey==='genre') ? ((meta && meta.total_words) || 0)
               : (levelKey==='character') ? (meta.total_words_spoken||0) : 0;
    return Math.max(0, tw - (n-1));
  }

  function aggregatePostings(postingsArray, n) {
    // Merge multiple token postings (for regex matches)
    const merged = new Map();
    for (const postings of postingsArray) {
      for (const [id, count] of postings) {
        merged.set(id, (merged.get(id) || 0) + count);
      }
    }
    return Array.from(merged.entries());
  }

  function buildRowsForTerms(terms){
    const granVal = gran.value;
    const isRegex = (matchMode.value === 'regex');
    const ngramModeVal = ngramMode.value;
    const n = parseInt(ngramModeVal, 10);
    const activeTerms = (terms || []).map(t => t.trim()).filter(Boolean);
    if (activeTerms.length === 0) return null;

    const termKeys = activeTerms.map((_, i) => `t${i}`);
    const includeCounts = termDisplayMode !== 'pct';
    const includePct = termDisplayMode !== 'counts';

    // Character view limitation
    if (granVal === 'character' && n > 3) {
      theadRow.innerHTML = '';
      tbody.innerHTML = '<tr><td class="muted">Character view supports up to trigrams.</td></tr>';
      return null;
    }

    const idx = (granVal === 'character') 
      ? (n === 1 ? tokensChar : n === 2 ? tokensChar2 : tokensChar3)
      : (n === 1 ? tokens : n === 2 ? tokens2 : tokens3);

    const compiledRegexes = [];
    if (isRegex) {
      for (const term of activeTerms) {
        try { compiledRegexes.push(new RegExp(term.trim(), 'i')); }
        catch (e) {
          theadRow.innerHTML = '';
          tbody.innerHTML = `<tr><td class="warning">Invalid regex: ${e.message}</td></tr>`;
          return null;
        }
      }
    }

    const rowsMap = new Map();
    function ensureRow(key, buildFn) {
      if (!rowsMap.has(key)) rowsMap.set(key, buildFn());
      return rowsMap.get(key);
    }
    function finalizeRows(includeCounts, includePct) {
      const arr = Array.from(rowsMap.values());
      arr.forEach(r => {
        termKeys.forEach((tk) => {
          const cKey = `${tk}_count`;
          if (includeCounts && r[cKey] == null) r[cKey] = 0;
          if (includePct) {
            const pKey = `${tk}_pct`;
            if (r[pKey] == null) r[pKey] = 0;
          }
        });
      });
      return arr;
    }
    function buildTermColumns(includeCounts = true, includePct = true) {
      const cols = [];
      activeTerms.forEach((term, idx) => {
        if (includeCounts) cols.push({ key: `${termKeys[idx]}_count`, label: `"${term}" hits`, type: 'number', defaultDir: 'desc' });
        if (includePct) cols.push({ key: `${termKeys[idx]}_pct`, label: `"${term}" %`, type: 'number', defaultDir: 'desc' });
      });
      return cols;
    }
    function getPostingsForTerm(termIdx) {
      if (isRegex) {
        const pattern = compiledRegexes[termIdx];
        if (!pattern) return [];
        return aggregatePostings(Object.keys(idx).filter(k => pattern.test(k)).map(k => idx[k]), n);
      }
      const parts = activeTerms[termIdx].toLowerCase().split(/\s+/).filter(Boolean);
      const key = parts.slice(0, n).join(' ');
      return idx[key] || [];
    }

    const genreTotals = new Map();
    if (granVal === 'genre') {
      plays.forEach(play => {
        const g = play.genre || 'unknown';
        genreTotals.set(g, (genreTotals.get(g) || 0) + (play.total_words || 0));
      });
    }

    if (granVal === 'line') {
      if (!Array.isArray(allLines) || allLines.length === 0) {
        theadRow.innerHTML = '';
        tbody.innerHTML = '<tr><td class="muted">Lines data not available.</td></tr>';
        return null;
      }
      const lineRegexes = [];
      if (isRegex) {
        for (const term of activeTerms) {
          try { lineRegexes.push(new RegExp(term.trim(), 'gi')); }
          catch (e) {
            theadRow.innerHTML = '';
            tbody.innerHTML = `<tr><td class="warning">Invalid regex: ${e.message}</td></tr>`;
            return null;
          }
        }
      } else {
        activeTerms.forEach(term => {
          const terms = term.trim().toLowerCase().split(/\s+/).filter(Boolean).slice(0, n);
          if (terms.length === 0) { lineRegexes.push(null); return; }
          const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const pat = '\\b' + terms.map(esc).join('\\s+') + '\\b';
          lineRegexes.push(new RegExp(pat, 'gi'));
        });
      }
      const highlightParts = lineRegexes.filter(Boolean).map(r => r.source);
      const highlightRe = (!highlightEnabled || highlightParts.length === 0) ? null : new RegExp(highlightParts.join('|'), 'gi');

      for (const ln of allLines) {
        const clean = (ln.text || '').toString().replace(/\s+/g, ' ').trim();
        let hasTerm = false;
        const row = {
          id: ln.canonical_id,
          play_id: ln.play_id,
          play_title: (playsById.get(ln.play_id) || {}).title || '',
          act: ln.act,
          scene: ln.scene,
          act_label: ln.act_label,
          scene_label: ln.scene_label,
          line_num: ln.line_num,
          speaker: ln.speaker || '',
          line: clean
        };
        lineRegexes.forEach((re, idx) => {
          if (!re) return;
          const c = countRegexMatches(clean, re);
          if (c > 0) {
            hasTerm = true;
            row[`${termKeys[idx]}_count`] = c;
          }
        });
        if (hasTerm) {
          row.line_html = highlightRe ? highlightHTML(clean, highlightRe) : escapeHTML(clean);
          rowsMap.set(row.id, row);
        }
      }

      const baseCols = [
        { key: 'id', label: 'Location', defaultDir: 'asc', type: 'text' },
        { key: 'speaker', label: 'Speaker', defaultDir: 'asc', type: 'text' }
      ];
      const termCols = buildTermColumns(true, false);
      baseCols.push(...termCols);
      baseCols.push({ key: 'line', label: 'Line', type: 'text' });
      setHeaders(baseCols);
      if (termCols.length) { sortKey = termCols[0].key; sortDir = 'desc'; }
      return finalizeRows(true, false);
    }

    if (granVal==='scene'){
      const baseCols = [
        {key:'id', label:'Location', defaultDir:'asc', type:'text'},
        {key:'play_title', label:'Play', defaultDir:'asc', type:'text'},
        {key:'act', label:'Act', type:'number'},
        {key:'scene', label:'Scene', type:'number'},
        {key:'ngram_count', label: n===1 ? 'Word count' : n===2 ? 'Bigram count' : 'Trigram count', type:'number'}
      ];
      activeTerms.forEach((term, termIdx) => {
        const postings = getPostingsForTerm(termIdx);
        for (const [scene_id, count] of postings){
          const m = chunkById.get(scene_id); if (!m) continue;
          const row = ensureRow(scene_id, () => {
            const totalWords = m.total_words || 0;
            const ngramCount = Math.max(0, totalWords - (n - 1));
            return { id: m.canonical_id, play_title: m.play_title, genre:m.genre, play_id:m.play_id, act:m.act, scene:m.scene, total_words:totalWords, ngram_count:ngramCount, scene_id };
          });
          const d = denomFor(n,'scene',m);
          row[`${termKeys[termIdx]}_count`] = count;
          row[`${termKeys[termIdx]}_pct`] = d ? count/d : 0;
        }
      });
      const termCols = buildTermColumns(includeCounts, includePct);
      setHeaders([...baseCols, ...termCols]);
      if (termCols.length) { sortKey = termCols[0].key; sortDir = 'desc'; }
      return finalizeRows(includeCounts, includePct);
    }

    if (granVal==='act'){
      const baseCols = [
        {key:'id', label:'Location', defaultDir:'asc', type:'text'},
        {key:'play_title', label:'Play', defaultDir:'asc', type:'text'},
        {key:'act', label:'Act', type:'number'},
        {key:'ngram_count', label: n===1 ? 'Word count' : n===2 ? 'Bigram count' : 'Trigram count', type:'number'}
      ];
      activeTerms.forEach((term, termIdx) => {
        const postings = getPostingsForTerm(termIdx);
        const countsByAct = new Map();
        for (const [scene_id,c] of postings){
          const m = chunkById.get(scene_id); if (!m) continue;
          const k = `${m.play_id}:${m.act}`;
          countsByAct.set(k, (countsByAct.get(k)||0) + c);
        }
        for (const [k,count] of countsByAct.entries()){
          const [pidStr, actNumStr] = k.split(':');
          const pid = parseInt(pidStr, 10);
          const actNum = parseInt(actNumStr, 10);
          const play = playsById.get(pid);
          if (!play) continue;
          const row = ensureRow(k, () => {
            const total_words = actTotals.get(k) || 0;
            const ngramCount = Math.max(0, total_words - (n - 1));
            return { id: `${play.abbr}.${actNum}`, play_title: play.title, genre:play.genre, play_id:pid, act:actNum, total_words, ngram_count:ngramCount };
          });
          const d = denomFor(n,'act',{play_id:pid,act:actNum});
          row[`${termKeys[termIdx]}_count`] = count;
          row[`${termKeys[termIdx]}_pct`] = d ? count/d : 0;
        }
      });
      const termCols = buildTermColumns(includeCounts, includePct);
      setHeaders([...baseCols, ...termCols]);
      if (termCols.length) { sortKey = termCols[0].key; sortDir = 'desc'; }
      return finalizeRows(includeCounts, includePct);
    }

    if (granVal==='play'){
      const baseCols = [
        {key:'id', label:'Location', defaultDir:'asc', type:'text'},
        {key:'title', label:'Play', defaultDir:'asc', type:'text'},
        {key:'genre', label:'Genre', defaultDir:'asc', type:'text'},
        {key:'first_year', label:'Year', type:'number'},
        {key:'num_lines', label:'# lines', type:'number'},
        {key:'ngram_count', label: n===1 ? 'Word count' : n===2 ? 'Bigram count' : 'Trigram count', type:'number'}
      ];
      activeTerms.forEach((term, termIdx) => {
        const postings = getPostingsForTerm(termIdx);
        const countsByPlay = new Map();
        for (const [scene_id,c] of postings){
          const m = chunkById.get(scene_id); if (!m) continue;
          countsByPlay.set(m.play_id, (countsByPlay.get(m.play_id)||0) + c);
        }
        for (const [pid,count] of countsByPlay.entries()){
          const p = playsById.get(pid);
          if (!p) continue;
          const row = ensureRow(pid, () => {
            const total_words = p.total_words ?? 0;
            const ngramCount = Math.max(0, total_words - (n - 1));
            return { id:p.abbr, play_id:pid, title:p.title, genre:p.genre, first_year:p.first_performance_year||'', num_lines:p.total_lines ?? 0, total_words, ngram_count:ngramCount };
          });
          const d = denomFor(n,'play',{play_id:pid});
          row[`${termKeys[termIdx]}_count`] = count;
          row[`${termKeys[termIdx]}_pct`] = d ? count/d : 0;
        }
      });
      const termCols = buildTermColumns(includeCounts, includePct);
      setHeaders([...baseCols, ...termCols]);
      if (termCols.length) { sortKey = termCols[0].key; sortDir = 'desc'; }
      return finalizeRows(includeCounts, includePct);
    }

    if (granVal==='genre'){
      const baseCols = [
        {key:'genre', label:'Genre', defaultDir:'asc', type:'text'},
        {key:'ngram_count', label: n===1 ? 'Word count' : n===2 ? 'Bigram count' : 'Trigram count', type:'number'}
      ];
      activeTerms.forEach((term, termIdx) => {
        const postings = getPostingsForTerm(termIdx);
        const countsByGenre = new Map();
        for (const [scene_id,c] of postings){
          const m = chunkById.get(scene_id); if (!m) continue;
          const genre = m.genre || 'unknown';
          countsByGenre.set(genre, (countsByGenre.get(genre)||0) + c);
        }
        for (const [genre,count] of countsByGenre.entries()){
          const totalWords = genreTotals.get(genre) || 0;
          const row = ensureRow(genre, () => {
            const ngramCount = Math.max(0, totalWords - (n - 1));
            return { genre, total_words: totalWords, ngram_count:ngramCount };
          });
          const denom = denomFor(n, 'genre', { total_words: totalWords });
          row[`${termKeys[termIdx]}_count`] = count;
          row[`${termKeys[termIdx]}_pct`] = denom ? count/denom : 0;
        }
      });
      const termCols = buildTermColumns(includeCounts, includePct);
      setHeaders([...baseCols, ...termCols]);
      if (termCols.length) { sortKey = termCols[0].key; sortDir = 'desc'; }
      return finalizeRows(includeCounts, includePct);
    }

    if (granVal==='character'){
      const baseCols = [
        {key:'name', label:'Character', defaultDir:'asc', type:'text'},
        {key:'gender', label:'Gender', defaultDir:'asc', type:'text'},
        {key:'play_title', label:'Play', defaultDir:'asc', type:'text'},
        {key:'ngram_count', label: n===1 ? 'Word count' : n===2 ? 'Bigram count' : 'Trigram count', type:'number'}
      ];
      activeTerms.forEach((term, termIdx) => {
        const postings = getPostingsForTerm(termIdx);
        for (const [char_id, count] of postings){
          const c = charactersById.get(char_id);
          if (!c) continue;
          const row = ensureRow(char_id, () => {
            const totalWords = c.total_words_spoken || 0;
            const ngramCount = Math.max(0, totalWords - (n - 1));
            const gender = (c.gender ?? c.sex ?? 'A').toString().toUpperCase();
            return { play_title:c.play_title, name:c.name, gender, total_words_spoken:totalWords, ngram_count:ngramCount };
          });
          const denom = denomFor(n,'character',c);
          row[`${termKeys[termIdx]}_count`] = count;
          row[`${termKeys[termIdx]}_pct`] = denom ? count/denom : 0;
        }
      });
      const termCols = buildTermColumns(includeCounts, includePct);
      setHeaders([...baseCols, ...termCols]);
      if (termCols.length) { sortKey = termCols[0].key; sortDir = 'desc'; }
      return finalizeRows(includeCounts, includePct);
    }
  }

  function applySegmentsFilters(rows) {
    let out = rows;
    const segFilters = getSegmentsFiltersMap();
    for (const [key, f] of segFilters.entries()) {
      if (!f) continue;
      const type = f.type || 'text';
      if (type === 'number') {
        const hasMin = f.min != null && f.min !== '';
        const hasMax = f.max != null && f.max !== '';
        if (!hasMin && !hasMax) continue;
        const isPct = key === 'pct' || key.endsWith('_pct');
        const minVal = hasMin ? parseFloat(f.min) : -Infinity;
        const maxVal = hasMax ? parseFloat(f.max) : Infinity;
        const m = isPct && minVal > 1 ? minVal/100 : minVal;
        const M = isPct && maxVal > 1 ? maxVal/100 : maxVal;
        out = out.filter(r => {
          const v = r[key];
          if (!Number.isFinite(v)) return false;
          return v >= m && v <= M;
        });
      } else {
        if (!f.pattern) continue;
        let re = null;
        try { re = new RegExp(f.pattern, 'i'); } catch(e) { re = null; }
        if (!re) continue;
        out = out.filter(r => re.test(String(r[key] ?? '')));
      }
    }
    return out;
  }
  function renderRows(rows){
    tbody.innerHTML='';
    const colSpan = Math.max(1, theadRow.children.length || 8);
    if (!rows || rows.length===0){ 
      tbody.innerHTML = `<tr><td colspan="${colSpan}" class="muted">No results.</td></tr>`; 
      document.getElementById('segmentsPagination').style.display = 'none';
      updateSegmentsFilterActions();
      return; 
    }
    // Keep base rows for later re-filtering
    lastSegmentsBaseRows = rows.slice();
    // Apply per-column filters
    rows = applySegmentsFilters(rows);
    if (rows.length === 0) { 
      tbody.innerHTML = `<tr><td colspan="${colSpan}" class="muted">No results match the filters.</td></tr>`; 
      document.getElementById('segmentsPagination').style.display = 'none';
      updateSegmentsFilterActions();
      return; 
    }
    
    rows = sortRows(rows);
    updateSortIndicators();
    
    // Store all rows and reset to page 1
    segmentsAllRows = rows;
    segmentsCurrentPage = 1;
    
    renderSegmentsPage();
  }
  function refreshSegmentsFromFilters() {
    if (!lastSegmentsBaseRows || lastSegmentsBaseRows.length === 0) return;
    let rows = applySegmentsFilters(lastSegmentsBaseRows);
    if (rows.length === 0) {
      const colSpan = Math.max(1, theadRow.children.length || 8);
      tbody.innerHTML = `<tr><td colspan="${colSpan}" class="muted">No results match the filters.</td></tr>`;
      document.getElementById('segmentsPagination').style.display = 'none';
      updateSegmentsFilterActions();
      return;
    }
    rows = sortRows(rows);
    segmentsAllRows = rows;
    segmentsCurrentPage = 1;
    renderSegmentsPage();
  }

  // Column filter popover
  let currentFilterPopover = null;
  function closeFilterPopover() {
    if (currentFilterPopover && currentFilterPopover.parentNode) {
      currentFilterPopover.parentNode.removeChild(currentFilterPopover);
    }
    currentFilterPopover = null;
  }
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeFilterPopover(); });
  document.addEventListener('click', (e) => {
    if (currentFilterPopover && !currentFilterPopover.contains(e.target) && !(e.target.classList && e.target.classList.contains('filter-icon'))) {
      closeFilterPopover();
    }
  });
  function showFilterPopover(th, key, type, table) {
    closeFilterPopover();
    const rect = th.getBoundingClientRect();
    const pop = document.createElement('div');
    pop.className = 'filter-popover';
    let stateMap = (table === 'lines') ? linesColumnFilters : getSegmentsFiltersMap();
    const existing = stateMap.get(key) || { type };
    if (type === 'number') {
      pop.innerHTML = `
        <h4>Filter: ${th.textContent.replace('⚙','').trim()}</h4>
        <div class="row"><label style="width:3rem;">Min</label><input type="number" step="any" class="f-min" value="${existing.min ?? ''}" placeholder="min"></div>
        <div class="row"><label style="width:3rem;">Max</label><input type="number" step="any" class="f-max" value="${existing.max ?? ''}" placeholder="max"></div>
        <div class="actions"><button class="link-btn f-clear">Clear</button><button class="link-btn f-close">Close</button></div>
        <div class="hint">Tip: for % columns you may enter 5 or 0.05</div>
      `;
    } else {
      pop.innerHTML = `
        <h4>Filter: ${th.textContent.replace('⚙','').trim()}</h4>
        <div class="row"><input type="text" class="f-pattern" value="${existing.pattern ?? ''}" placeholder="Regex pattern (case-insensitive)"></div>
        <div class="actions"><button class="link-btn f-clear">Clear</button><button class="link-btn f-close">Close</button></div>
        <div class="hint">Examples: ^Act, Juliet$ , love|death</div>
      `;
    }
    document.body.appendChild(pop);
    currentFilterPopover = pop;
    const top = rect.bottom + window.scrollY + 6;
    let left = rect.left + window.scrollX;
    if (left + pop.offsetWidth > window.scrollX + window.innerWidth) {
      left = window.scrollX + window.innerWidth - pop.offsetWidth - 12;
    }
    pop.style.top = top + 'px';
    pop.style.left = left + 'px';

    const applyNumber = debounce(() => {
      const minV = pop.querySelector('.f-min').value;
      const maxV = pop.querySelector('.f-max').value;
      if (minV === '' && maxV === '') stateMap.delete(key);
      else stateMap.set(key, { type: 'number', min: minV, max: maxV });
      if (table === 'lines') { renderLinesPage(); updateLinesFilterActions(); updateDeepLink(); } else { refreshSegmentsFromFilters(); updateSegmentsFilterActions(); updateDeepLink(); }
    }, 200);
    const applyText = debounce(() => {
      const pat = pop.querySelector('.f-pattern').value.trim();
      if (!pat) stateMap.delete(key);
      else stateMap.set(key, { type: 'text', pattern: pat });
      if (table === 'lines') { renderLinesPage(); updateLinesFilterActions(); updateDeepLink(); } else { refreshSegmentsFromFilters(); updateSegmentsFilterActions(); updateDeepLink(); }
    }, 200);
    if (type === 'number') {
      pop.querySelector('.f-min').addEventListener('input', applyNumber);
      pop.querySelector('.f-max').addEventListener('input', applyNumber);
    } else {
      pop.querySelector('.f-pattern').addEventListener('input', applyText);
    }
    pop.querySelector('.f-clear').addEventListener('click', (e) => {
      e.preventDefault();
      stateMap.delete(key);
      if (table === 'lines') { renderLinesPage(); updateLinesFilterActions(); updateDeepLink(); } else { refreshSegmentsFromFilters(); updateSegmentsFilterActions(); updateDeepLink(); }
    });
    pop.querySelector('.f-close').addEventListener('click', (e) => { e.preventDefault(); closeFilterPopover(); });
  }
  
  function renderSegmentsPage() {
    const totalPages = getTotalPages(segmentsAllRows.length, segmentsPageSize);
    const paginatedRows = paginateArray(segmentsAllRows, segmentsCurrentPage, segmentsPageSize);
    
    tbody.innerHTML = '';
    const cols = Array.from(theadRow.children).map(th => th.dataset.key);
    const firstColKey = cols[0];
    
    for (const r of paginatedRows) {
      const tr = document.createElement('tr');
      cols.forEach((k, idx) => {
        const td = document.createElement('td');
        if (k === 'act' && r.act_label) {
          td.textContent = r.act_label;
        } else if (k === 'scene' && r.scene_label) {
          td.textContent = r.scene_label;
        } else if (k === 'pct' || k.endsWith('_pct')) {
          td.textContent = fmtPct(r[k]||0);
        } else if (k === 'line' && r.line_html) {
          td.innerHTML = r.line_html;
        } else {
          const v = r[k];
          td.textContent = (v === undefined || v === null) ? '' : v;
        }
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    }
    
    // Update sort indicators
    updateSortIndicators();
    
    // Update pagination controls
    const paginationDiv = document.getElementById('segmentsPagination');
    paginationDiv.style.display = segmentsAllRows.length > 25 ? 'flex' : 'none';
    
    document.getElementById('segmentsPageInfo').textContent = `Page ${segmentsCurrentPage} of ${totalPages}`;
    document.getElementById('segmentsTotalInfo').textContent = `(${segmentsAllRows.length} total rows)`;
    
    document.getElementById('segmentsFirstPage').disabled = segmentsCurrentPage === 1;
    document.getElementById('segmentsPrevPage').disabled = segmentsCurrentPage === 1;
    document.getElementById('segmentsNextPage').disabled = segmentsCurrentPage === totalPages;
    document.getElementById('segmentsLastPage').disabled = segmentsCurrentPage === totalPages;
    // Apply color scales if enabled
    applyOrClear('#results');
    updateDeepLink();
    updateSegmentsFilterActions();
  }

  // removed copy/jump actions
  document.getElementById('results').addEventListener('click', (e) => {});

  // Clear all filters for current granularity
  const clearSegFiltersBtn = document.getElementById('clearSegmentsFilters');
  if (clearSegFiltersBtn) {
    clearSegFiltersBtn.addEventListener('click', (e) => {
      e.preventDefault();
      const m = getSegmentsFiltersMap();
      if (m.size === 0) return;
      m.clear();
      refreshSegmentsFromFilters();
      updateSegmentsFilterActions();
      updateDeepLink();
    });
  }

  // Clear all filters for lines table
  const clearLinesFiltersBtn = document.getElementById('clearLinesFilters');
  if (clearLinesFiltersBtn) {
    clearLinesFiltersBtn.addEventListener('click', (e) => {
      e.preventDefault();
      if (linesColumnFilters.size === 0) return;
      linesColumnFilters.clear();
      renderLinesPage();
      updateLinesFilterActions();
      updateDeepLink();
    });
  }

  function buildHighlightRegexFromState() { return null; }

  async function showLineContext() {}

  function showDrillDown(rowData, firstColKey) {
    const granVal = gran.value;
    const ngramModeVal = ngramMode.value;
    const n = parseInt(ngramModeVal);
    
    // Clear current selections and add the appropriate segment
    ngramsSelectedSegments.clear();
    
    let segmentToAdd = null;
    
    if (granVal === 'play') {
      const playId = rowData.play_id;
      const play = playsById.get(playId);
      if (play) {
        segmentToAdd = {
          type: 'play',
          id: playId,
          label: play.title
        };
      }
    } else if (granVal === 'genre') {
      const genre = rowData.genre;
      segmentToAdd = {
        type: 'genre',
        id: genre,
        label: genre
      };
    } else if (granVal === 'character') {
      const charName = rowData.name;
      const playTitle = rowData.play_title;
      // Find character_id
      let charId = null;
      for (const [id, c] of charactersById) {
        if (c.name === charName && c.play_title === playTitle) {
          charId = id;
          segmentToAdd = {
            type: 'character',
            id: charId,
            label: `${charName} (${playTitle})`
          };
          break;
        }
      }
    } else if (granVal === 'act') {
      const playId = rowData.play_id;
      const actNum = rowData.act;
      const play = playsById.get(playId);
      if (play) {
        segmentToAdd = {
          type: 'act',
          id: `${playId}:${actNum}`,
          label: `${play.title} - Act ${actNum}`
        };
      }
    } else if (granVal === 'scene') {
      const sceneId = rowData.scene_id;
      const chunk = chunkById.get(sceneId);
      if (chunk) {
        const play = playsById.get(chunk.play_id);
        segmentToAdd = {
          type: 'scene',
          id: sceneId,
          label: `${play.title} - Act ${chunk.act}, Scene ${chunk.scene}`
        };
      }
    }
    
    // Set the ngram mode to match the current search
    document.getElementById('ngramsNgramMode').value = n.toString();
    
    // Switch to ngrams tab first
    tabBtns.forEach(b => b.classList.remove('active'));
    document.querySelector('[data-tab="ngrams"]').classList.add('active');
    segmentsTab.style.display = 'none';
    ngramsTab.style.display = 'block';
    
    // Add the segment and build the comparison table
    if (segmentToAdd) {
      ngramsSelectedSegments.add(segmentToAdd);
      renderAvailableSegments();
      renderSelectedSegments();
      buildNgramsComparison();
    }
    
    ngramsTab.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  function renderNgramsPage() {
    const totalPages = getTotalPages(ngramsAllRows.length, ngramsPageSize);
    const paginatedRows = paginateArray(ngramsAllRows, ngramsCurrentPage, ngramsPageSize);
    
    const tbody = document.getElementById('ngramsTableBody');
    if (!tbody) return;
    
    tbody.innerHTML = '';
    for (const [token, count] of paginatedRows) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${token}</td><td>${count}</td>`;
      tbody.appendChild(tr);
    }
    
    // Update pagination controls
    const paginationDiv = document.getElementById('ngramsPagination');
    paginationDiv.style.display = ngramsAllRows.length > 25 ? 'flex' : 'none';
    
    document.getElementById('ngramsPageInfo').textContent = `Page ${ngramsCurrentPage} of ${totalPages}`;
    document.getElementById('ngramsTotalInfo').textContent = `(${ngramsAllRows.length} total rows)`;
    
    document.getElementById('ngramsFirstPage').disabled = ngramsCurrentPage === 1;
    document.getElementById('ngramsPrevPage').disabled = ngramsCurrentPage === 1;
    document.getElementById('ngramsNextPage').disabled = ngramsCurrentPage === totalPages;
    document.getElementById('ngramsLastPage').disabled = ngramsCurrentPage === totalPages;
    // Apply color scales if enabled
    applyOrClear('#ngramsTable');
  }

  // Check if segments settings have changed
  function checkSegmentsPendingChanges() {
    const currentState = {
      query: q.value.trim(),
      ngramMode: ngramMode.value,
      gran: gran.value,
      matchMode: matchMode.value,
      termDisplayMode
    };
    const currentExtras = extraTerms.map(normalizeTerm).filter(Boolean).sort();
    const lastExtras = (lastSegmentsState.extraTerms || []).map(normalizeTerm).filter(Boolean).sort();
    
    const hasChanges = 
      currentState.query !== lastSegmentsState.query ||
      currentState.ngramMode !== lastSegmentsState.ngramMode ||
      currentState.gran !== lastSegmentsState.gran ||
      currentState.matchMode !== lastSegmentsState.matchMode ||
      currentState.termDisplayMode !== lastSegmentsState.termDisplayMode ||
      currentExtras.join('|') !== lastExtras.join('|');
    
    segmentsPendingChanges = hasChanges;
    updateSegmentsRefreshButton();
  }
  
  function updateSegmentsRefreshButton() {
    if (!go) return;
    if (segmentsPendingChanges) {
      go.classList.add('refresh-btn-pending');
      go.textContent = 'Refresh ⟳';
    } else {
      go.classList.remove('refresh-btn-pending');
      go.textContent = 'Refresh';
    }
  }
  // Update deep link initially
  updateDeepLink();
  
  function saveSegmentsState() {
    lastSegmentsState = {
      query: q.value.trim(),
      ngramMode: ngramMode.value,
      gran: gran.value,
      matchMode: matchMode.value,
      termDisplayMode,
      extraTerms: [...extraTerms]
    };
    segmentsPendingChanges = false;
    updateSegmentsRefreshButton();
    updateDeepLink();
  }
  
  // Check if ngrams settings have changed
  function checkNgramsPendingChanges() {
    const currentQuery = document.getElementById('ngramsQuery').value.trim();
    const currentNgramMode = document.getElementById('ngramsNgramMode').value;
    const currentMatchMode = document.getElementById('ngramsMatchMode').value;
    const currentDisplayMode = document.getElementById('ngramsDisplayMode').value;
    
    // Create a comparable representation of selected segments
    const currentSegmentsStr = Array.from(ngramsSelectedSegments)
      .map(s => `${s.type}:${s.id}`)
      .sort()
      .join(',');
    const lastSegmentsStr = Array.from(lastNgramsState.segments)
      .map(s => `${s.type}:${s.id}`)
      .sort()
      .join(',');
    
    const hasChanges = 
      currentQuery !== lastNgramsState.query ||
      currentNgramMode !== lastNgramsState.ngramMode ||
      currentMatchMode !== lastNgramsState.matchMode ||
      currentDisplayMode !== lastNgramsState.displayMode ||
      currentSegmentsStr !== lastSegmentsStr;
    
    ngramsPendingChanges = hasChanges;
    updateNgramsRefreshButton();
  }
  
  function updateNgramsRefreshButton() {
    const refreshBtn = document.getElementById('ngramsRefresh');
    if (!refreshBtn) return;
    if (ngramsPendingChanges) {
      refreshBtn.classList.add('refresh-btn-pending');
      refreshBtn.textContent = 'Refresh ⟳';
    } else {
      refreshBtn.classList.remove('refresh-btn-pending');
      refreshBtn.textContent = 'Refresh';
    }
  }
  
  function saveNgramsState() {
    lastNgramsState = {
      query: document.getElementById('ngramsQuery').value.trim(),
      ngramMode: document.getElementById('ngramsNgramMode').value,
      matchMode: document.getElementById('ngramsMatchMode').value,
      displayMode: document.getElementById('ngramsDisplayMode').value,
      segments: new Set(Array.from(ngramsSelectedSegments).map(s => ({type: s.type, id: s.id})))
    };
    ngramsPendingChanges = false;
    updateNgramsRefreshButton();
  }

  function doSearch(){
    pruneExtraTermsAgainstPrimary();
    const terms = getActiveTerms();
    if (terms.length === 0){ tbody.innerHTML = ''; ngramTableContainer.innerHTML=''; return; }
    const rows = buildRowsForTerms(terms);
    if (rows) {
      renderRows(rows);
      saveSegmentsState();
    }
  }

  if (go) go.addEventListener('click', doSearch);
  q.addEventListener('keydown', e => { if (e.key==='Enter') doSearch(); });
  // per-column filters are handled via header filter icons; removed global min filters

  // Removed play selection buttons (use column filters)
  
  // Segments pagination controls
  document.getElementById('segmentsFirstPage').addEventListener('click', () => {
    segmentsCurrentPage = 1;
    renderSegmentsPage();
  });
  document.getElementById('segmentsPrevPage').addEventListener('click', () => {
    if (segmentsCurrentPage > 1) {
      segmentsCurrentPage--;
      renderSegmentsPage();
    }
  });
  document.getElementById('segmentsNextPage').addEventListener('click', () => {
    const totalPages = getTotalPages(segmentsAllRows.length, segmentsPageSize);
    if (segmentsCurrentPage < totalPages) {
      segmentsCurrentPage++;
      renderSegmentsPage();
    }
  });
  document.getElementById('segmentsLastPage').addEventListener('click', () => {
    segmentsCurrentPage = getTotalPages(segmentsAllRows.length, segmentsPageSize);
    renderSegmentsPage();
  });
  document.getElementById('segmentsPageSize').addEventListener('change', (e) => {
    segmentsPageSize = parseInt(e.target.value);
    segmentsCurrentPage = 1;
    renderSegmentsPage();
  });
  
  // Ngrams pagination controls
  document.getElementById('ngramsFirstPage').addEventListener('click', () => {
    ngramsCurrentPage = 1;
    if (ngramsAllRows.length > 0 && ngramsAllRows[0].hasOwnProperty('seg0_count')) {
      renderNgramsComparisonPage();
    } else {
      renderNgramsPage();
    }
  });
  document.getElementById('ngramsPrevPage').addEventListener('click', () => {
    if (ngramsCurrentPage > 1) {
      ngramsCurrentPage--;
      if (ngramsAllRows.length > 0 && ngramsAllRows[0].hasOwnProperty('seg0_count')) {
        renderNgramsComparisonPage();
      } else {
        renderNgramsPage();
      }
    }
  });
  document.getElementById('ngramsNextPage').addEventListener('click', () => {
    const totalPages = getTotalPages(ngramsAllRows.length, ngramsPageSize);
    if (ngramsCurrentPage < totalPages) {
      ngramsCurrentPage++;
      if (ngramsAllRows.length > 0 && ngramsAllRows[0].hasOwnProperty('seg0_count')) {
        renderNgramsComparisonPage();
      } else {
        renderNgramsPage();
      }
    }
  });
  document.getElementById('ngramsLastPage').addEventListener('click', () => {
    ngramsCurrentPage = getTotalPages(ngramsAllRows.length, ngramsPageSize);
    if (ngramsAllRows.length > 0 && ngramsAllRows[0].hasOwnProperty('seg0_count')) {
      renderNgramsComparisonPage();
    } else {
      renderNgramsPage();
    }
  });
  document.getElementById('ngramsPageSize').addEventListener('change', (e) => {
    ngramsPageSize = parseInt(e.target.value);
    ngramsCurrentPage = 1;
    if (ngramsAllRows.length > 0 && ngramsAllRows[0].hasOwnProperty('seg0_count')) {
      renderNgramsComparisonPage();
    } else {
      renderNgramsPage();
    }
  });

  // Build ngrams comparison table
  function buildNgramsComparison() {
    if (ngramsSelectedSegments.size === 0) {
      ngramTableContainer.innerHTML = '<p class="muted">Select at least one context to compare.</p>';
      document.getElementById('ngramsPagination').style.display = 'none';
      return;
    }
    
    const n = parseInt(document.getElementById('ngramsNgramMode').value);
    const displayMode = document.getElementById('ngramsDisplayMode').value;
    const queryTerm = document.getElementById('ngramsQuery').value.trim();
    const ngramsMatchMode = document.getElementById('ngramsMatchMode').value;
    
    // Get appropriate indices (separate scene-level and character-level)
    let sceneIdx = {};
    let charIdx = {};
    if (n === 1) {
      sceneIdx = tokens;
      charIdx = tokensChar;
    } else if (n === 2) {
      sceneIdx = tokens2;
      charIdx = tokensChar2;
    } else {
      sceneIdx = tokens3;
      charIdx = tokensChar3;
    }
    
    // Build frequency maps for each selected segment
    const segmentMaps = [];
    const segmentLabels = [];
    const segmentTotalWords = [];
    
    for (const seg of ngramsSelectedSegments) {
      const freqMap = new Map();
      let totalWords = 0;
      
      if (seg.type === 'play') {
        const playId = seg.id;
        const play = playsById.get(playId);
        totalWords = play ? play.total_words : 0;
        
        // Use scene-level index only
        for (const [token, postings] of Object.entries(sceneIdx)) {
          let total = 0;
          if (Array.isArray(postings)) {
            for (const posting of postings) {
              const [scene_id, count] = posting;
              const chunk = chunkById.get(scene_id);
              if (chunk && chunk.play_id === playId) total += count;
            }
          }
          if (total > 0) freqMap.set(token, total);
        }
      } else if (seg.type === 'genre') {
        const genre = seg.id;
        for (const play of plays) {
          if (play.genre === genre) totalWords += play.total_words || 0;
        }
        
        // Use scene-level index only
        for (const [token, postings] of Object.entries(sceneIdx)) {
          let total = 0;
          if (Array.isArray(postings)) {
            for (const posting of postings) {
              const [scene_id, count] = posting;
              const chunk = chunkById.get(scene_id);
              if (chunk && chunk.genre === genre) total += count;
            }
          }
          if (total > 0) freqMap.set(token, total);
        }
      } else if (seg.type === 'act') {
        // Parse act ID (format: "playId:actNum")
        const [playIdStr, actNumStr] = seg.id.split(':');
        const playId = parseInt(playIdStr);
        const actNum = parseInt(actNumStr);
        
        // Calculate total words for this act
        for (const chunk of chunks) {
          if (chunk.play_id === playId && chunk.act === actNum) {
            totalWords += chunk.total_words || 0;
          }
        }
        
        // Use scene-level index
        for (const [token, postings] of Object.entries(sceneIdx)) {
          let total = 0;
          if (Array.isArray(postings)) {
            for (const posting of postings) {
              const [scene_id, count] = posting;
              const chunk = chunkById.get(scene_id);
              if (chunk && chunk.play_id === playId && chunk.act === actNum) {
                total += count;
              }
            }
          }
          if (total > 0) freqMap.set(token, total);
        }
      } else if (seg.type === 'scene') {
        const sceneId = seg.id;
        const chunk = chunkById.get(sceneId);
        totalWords = chunk ? chunk.total_words : 0;
        
        // Use scene-level index
        for (const [token, postings] of Object.entries(sceneIdx)) {
          if (Array.isArray(postings)) {
            for (const posting of postings) {
              const [scene_id, count] = posting;
              if (scene_id === sceneId) {
                freqMap.set(token, count);
              }
            }
          }
        }
      } else if (seg.type === 'character') {
        const charId = seg.id;
        const char = charactersById.get(charId);
        totalWords = char ? char.total_words_spoken : 0;
        
        // Use character-level index only
        for (const [token, postings] of Object.entries(charIdx)) {
          if (Array.isArray(postings)) {
            for (const posting of postings) {
              const [char_id, count] = posting;
              if (char_id === charId) freqMap.set(token, count);
            }
          }
        }
      }
      
      segmentMaps.push(freqMap);
      segmentLabels.push(seg.label);
      segmentTotalWords.push(totalWords);
    }
    
    // Collect all unique tokens
    const allTokens = new Set();
    for (const freqMap of segmentMaps) {
      for (const token of freqMap.keys()) {
        allTokens.add(token);
      }
    }
    
    // Filter by query if provided
    let tokensToShow = Array.from(allTokens);
    if (queryTerm) {
      if (ngramsMatchMode === 'regex') {
        try {
          const pattern = new RegExp(queryTerm, 'i');
          tokensToShow = tokensToShow.filter(token => pattern.test(token));
        } catch (e) {
          ngramTableContainer.innerHTML = `<p class="warning">Invalid regex: ${e.message}</p>`;
          return;
        }
      } else {
        // Exact term matching (case-insensitive exact match)
        const lowerQuery = queryTerm.toLowerCase();
        tokensToShow = tokensToShow.filter(token => token.toLowerCase() === lowerQuery);
      }
    }
    
    // Build rows with filtered tokens
    const rows = [];
    for (const token of tokensToShow) {
      const row = { token };
      for (let i = 0; i < segmentMaps.length; i++) {
        const count = segmentMaps[i].get(token) || 0;
        const totalWords = segmentTotalWords[i];
        const pct = totalWords > 0 ? ((count / totalWords) * 100).toFixed(3) : '0.000';
        row[`seg${i}_count`] = count;
        row[`seg${i}_pct`] = parseFloat(pct);
      }
      // Calculate total count across all segments for sorting
      row.totalCount = segmentMaps.reduce((sum, map) => sum + (map.get(token) || 0), 0);
      rows.push(row);
    }
    
    // Store for pagination and sorting
    ngramsAllRows = rows;
    ngramsCurrentPage = 1;
    ngramsSortKey = 'totalCount';
    ngramsSortDir = 'desc';
    
    // Apply default sort
    sortNgramsRows();
    
    // Build HTML table
    const ngramLabel = n === 1 ? 'Unigram' : n === 2 ? 'Bigram' : 'Trigram';
    let html = `<h3>${ngramLabel} Comparison Across ${segmentLabels.length} Segment${segmentLabels.length > 1 ? 's' : ''}</h3>`;
    const matchInfo = queryTerm ? ` matching ${ngramsMatchMode === 'regex' ? 'pattern' : 'term'} "${queryTerm}"` : '';
    html += `<p class="muted">Showing ${rows.length} unique ${ngramLabel.toLowerCase()}s${matchInfo}</p>`;
    html += '<table id="ngramsTable"><thead><tr><th class="sortable-header" data-key="token" style="width: 30%;">' + ngramLabel + '</th>';
    
    // Add column headers for each segment
    for (let i = 0; i < segmentLabels.length; i++) {
      if (displayMode === 'hits') {
        html += `<th class="sortable-header" data-key="seg${i}_count">${segmentLabels[i]}<br><span class="muted" style="font-weight: normal;">Hits</span></th>`;
      } else if (displayMode === 'pct') {
        html += `<th class="sortable-header" data-key="seg${i}_pct">${segmentLabels[i]}<br><span class="muted" style="font-weight: normal;">%</span></th>`;
      } else { // both
        html += `<th class="sortable-header" data-key="seg${i}_count">${segmentLabels[i]}<br><span class="muted" style="font-weight: normal;">Hits</span></th>`;
        html += `<th class="sortable-header" data-key="seg${i}_pct">${segmentLabels[i]}<br><span class="muted" style="font-weight: normal;">%</span></th>`;
      }
    }
    
    html += '</tr></thead><tbody id="ngramsTableBody"></tbody></table>';
    ngramTableContainer.innerHTML = html;
    
    // Add click handlers to headers
    document.querySelectorAll('#ngramsTable .sortable-header').forEach(th => {
      th.style.cursor = 'pointer';
      th.title = 'Click to sort';
      th.addEventListener('click', () => {
        const key = th.dataset.key;
        if (ngramsSortKey === key) {
          ngramsSortDir = (ngramsSortDir === 'asc' ? 'desc' : 'asc');
        } else {
          ngramsSortKey = key;
          ngramsSortDir = (key === 'token' ? 'asc' : 'desc');
        }
        sortNgramsRows();
        ngramsCurrentPage = 1;
        renderNgramsComparisonPage();
      });
    });
    
    updateNgramsSortIndicators();
    renderNgramsComparisonPage();
    saveNgramsState();
  }
  
  function sortNgramsRows() {
    if (!ngramsSortKey || !ngramsAllRows.length) return;
    
    ngramsAllRows.sort((a, b) => {
      const av = a[ngramsSortKey];
      const bv = b[ngramsSortKey];
      
      if (typeof av === 'string' || typeof bv === 'string') {
        return ngramsSortDir === 'asc' 
          ? String(av).localeCompare(String(bv)) 
          : String(bv).localeCompare(String(av));
      }
      
      return ngramsSortDir === 'asc' ? (av - bv) : (bv - av);
    });
  }
  
  function updateNgramsSortIndicators() {
    document.querySelectorAll('#ngramsTable .sortable-header').forEach(th => {
      th.classList.remove('sorted-asc', 'sorted-desc');
      if (th.dataset.key === ngramsSortKey) {
        th.classList.add(ngramsSortDir === 'asc' ? 'sorted-asc' : 'sorted-desc');
      }
    });
  }
  
  function renderNgramsComparisonPage() {
    const tbody = document.getElementById('ngramsTableBody');
    if (!tbody || !Array.isArray(ngramsAllRows) || ngramsAllRows.length === 0) return;
    
    const displayMode = document.getElementById('ngramsDisplayMode').value;
    const totalPages = getTotalPages(ngramsAllRows.length, ngramsPageSize);
    const paginatedRows = paginateArray(ngramsAllRows, ngramsCurrentPage, ngramsPageSize);
    
    tbody.innerHTML = '';
    for (const row of paginatedRows) {
      const tr = document.createElement('tr');
      let html = `<td>${row.token}</td>`;
      
      // Add cells for each segment
      const numSegments = Math.floor((Object.keys(row).length - 2) / 2); // -2 for token and totalCount
      for (let i = 0; i < numSegments; i++) {
        if (displayMode === 'hits') {
          html += `<td>${row[`seg${i}_count`]}</td>`;
        } else if (displayMode === 'pct') {
          html += `<td>${row[`seg${i}_pct`].toFixed(3)}%</td>`;
        } else { // both
          html += `<td>${row[`seg${i}_count`]}</td>`;
          html += `<td>${row[`seg${i}_pct`].toFixed(3)}%</td>`;
        }
      }
      
      tr.innerHTML = html;
      tbody.appendChild(tr);
    }
    
    // Update sort indicators
    updateNgramsSortIndicators();
    
    // Update pagination controls
    const paginationDiv = document.getElementById('ngramsPagination');
    paginationDiv.style.display = ngramsAllRows.length > 25 ? 'flex' : 'none';
    
    document.getElementById('ngramsPageInfo').textContent = `Page ${ngramsCurrentPage} of ${totalPages}`;
    document.getElementById('ngramsTotalInfo').textContent = `(${ngramsAllRows.length} total rows)`;
    
    document.getElementById('ngramsFirstPage').disabled = ngramsCurrentPage === 1;
    document.getElementById('ngramsPrevPage').disabled = ngramsCurrentPage === 1;
    document.getElementById('ngramsNextPage').disabled = ngramsCurrentPage === totalPages;
    document.getElementById('ngramsLastPage').disabled = ngramsCurrentPage === totalPages;
    // Apply color scales if enabled
    applyOrClear('#ngramsTable');
  }
  
  // Ngrams tab controls
  const debouncedBuildNgrams = debounce(() => { if (ngramsSelectedSegments.size > 0) buildNgramsComparison(); }, 250);
  const ngramsQueryInput = document.getElementById('ngramsQuery');
  ngramsQueryInput.addEventListener('keydown', e => { 
    if (e.key === 'Enter' && ngramsSelectedSegments.size > 0) buildNgramsComparison(); 
  });
  ngramsQueryInput.addEventListener('input', () => { checkNgramsPendingChanges(); debouncedBuildNgrams(); });
  document.getElementById('ngramsNgramMode').addEventListener('change', () => { checkNgramsPendingChanges(); debouncedBuildNgrams(); });
  document.getElementById('ngramsDisplayMode').addEventListener('change', () => { checkNgramsPendingChanges(); debouncedBuildNgrams(); });
  document.getElementById('ngramsMatchMode').addEventListener('change', () => { checkNgramsPendingChanges(); debouncedBuildNgrams(); });

  // Segments tab controls - track changes
  const debouncedDoSearch = debounce(doSearch, 250);
  q.addEventListener('input', () => {
    const val = q.value;
    const hasRegexChars = /[.*+?^${}()|[\]\\]/.test(val);
    if (hasRegexChars && matchMode.value === 'exact') {
      matchMode.value = 'regex';
    }
    pruneExtraTermsAgainstPrimary();
    renderExtraTerms();
    checkSegmentsPendingChanges();
    debouncedDoSearch();
  });
  if (addTermBtn) {
    addTermBtn.addEventListener('click', () => {
      addExtraTerm(addTermInput.value);
      addTermInput.value = '';
    });
  }
  if (addTermInput) {
    addTermInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        addExtraTerm(addTermInput.value);
        addTermInput.value = '';
      }
    });
  }
  ngramMode.addEventListener('change', () => { checkSegmentsPendingChanges(); doSearch(); });
  gran.addEventListener('change', () => { checkSegmentsPendingChanges(); doSearch(); });
  matchMode.addEventListener('change', () => { checkSegmentsPendingChanges(); doSearch(); });

  // Color scale toggles
  document.querySelectorAll('.color-scale-toggle').forEach(cb => {
    cb.addEventListener('change', (e) => setColorScaleEnabled(e.target.checked));
  });
  if (termDisplayModeSel) {
    termDisplayModeSel.addEventListener('change', (e) => {
      termDisplayMode = e.target.value || 'both';
      checkSegmentsPendingChanges();
      doSearch();
    });
  }
  // Palette and steps options
  document.querySelectorAll('.color-scale-palette').forEach(sel => {
    sel.addEventListener('change', e => { colorScalePalette = e.target.value; syncColorScaleOptions(); applyColorScalesForVisibleTables(); updateDeepLink(); });
  });
  document.querySelectorAll('.color-scale-steps').forEach(sel => {
    sel.addEventListener('change', e => { colorScaleSteps = parseInt(e.target.value)||5; syncColorScaleOptions(); applyColorScalesForVisibleTables(); updateDeepLink(); });
  });
  // Ensure initial sync
  syncColorScaleToggles();
  syncColorScaleOptions();
  renderAllLegends();
  // Highlight toggle handlers
  document.querySelectorAll('.highlight-toggle').forEach(cb => {
    cb.addEventListener('change', (e) => { setHighlightEnabled(e.target.checked); updateDeepLink(); });
  });
  syncHighlightToggles();

  const downloadSegBtn = document.getElementById('downloadSegmentsCsv');
  if (downloadSegBtn) {
    downloadSegBtn.addEventListener('click', () => {
      const name = `segments-${gran.value}-${Date.now()}.csv`;
      downloadTableCsv('#results', name);
    });
  }

  // Lines tab state
  let linesCurrentPage = 1;
  let linesPageSize = 50;
  let linesAllRows = [];
  let linesPendingChanges = false;
  let lastLinesState = {
    query: '',
    ngramMode: '',
    matchMode: ''
  };

  // Removed lines play filter (use header regex filters instead)

  function buildLinesRows(query) {
    const isRegex = (document.getElementById('linesMatchMode').value === 'regex');
    const n = parseInt(document.getElementById('linesNgramMode').value);

    if (!allLines || allLines.length === 0) {
      return null;
    }

    const rows = [];
    
    // Build search pattern
    let searchPattern;
    if (isRegex) {
      try {
        searchPattern = new RegExp(query, 'i');
      } catch (e) {
        return null;
      }
    } else {
      // For exact term matching, create tokens from the line and check for n-gram match
      const queryTokens = query.trim().toLowerCase().split(/\s+/).filter(Boolean).slice(0, n);
      const queryNgram = queryTokens.join(' ');
      searchPattern = { type: 'exact', ngram: queryNgram, n };
    }

    // Search through lines
    for (const line of allLines) {
      
      let matches = false;
      let highlightedText = line.text;

      if (isRegex) {
        matches = searchPattern.test(line.text);
        if (matches && highlightEnabled) {
          highlightedText = line.text.replace(searchPattern, match => `<span class="hit">${match}</span>`);
        }
      } else {
        // Tokenize the line
        const lineTokens = line.text.toLowerCase()
          .replace(/[.,;:!?()[\]{}"']/g, ' ')
          .split(/\s+/)
          .filter(Boolean);
        
        // Check for n-gram match
        for (let i = 0; i <= lineTokens.length - n; i++) {
          const ngram = lineTokens.slice(i, i + n).join(' ');
          if (ngram === searchPattern.ngram) {
            matches = true;
            // Highlight the match in the original text
            const matchWords = lineTokens.slice(i, i + n);
            let tempText = line.text;
            const regex = new RegExp(matchWords.map(w => '\\b' + w + '\\b').join('\\s+'), 'gi');
            highlightedText = highlightEnabled ? tempText.replace(regex, match => `<span class="hit">${match}</span>`) : tempText;
            break;
          }
        }
      }

      if (matches) {
        const play = playsById.get(line.play_id);
        rows.push({
          play_title: play ? play.title : 'Unknown',
          play_id: line.play_id,
          act: line.act,
          scene: line.scene,
          line_num: line.line_num,
          speaker: line.speaker || '',
          text: highlightedText
        });
      }
    }

    return rows;
  }

  function setLinesHeaders() {
    const theadRow = document.getElementById('linesHeadRow');
    const cols = [
      { key: 'play_title', label: 'Play', defaultDir: 'asc', type: 'text' },
      { key: 'act', label: 'Act', type: 'number' },
      { key: 'scene', label: 'Scene', type: 'number' },
      { key: 'line_num', label: 'Line #', type: 'number' },
      { key: 'speaker', label: 'Speaker', defaultDir: 'asc', type: 'text' },
      { key: 'text', label: 'Text', defaultDir: 'asc', type: 'text' }
    ];

    theadRow.innerHTML = '';
    cols.forEach(c => {
      const th = document.createElement('th');
      th.textContent = c.label;
      th.dataset.key = c.key;
      th.dataset.type = c.type || 'text';
      if (c.key !== 'text') {
        th.title = 'Click to sort';
        th.style.cursor = 'pointer';
        th.addEventListener('click', () => {
          if (linesSortKey === c.key) {
            linesSortDir = (linesSortDir === 'asc' ? 'desc' : 'asc');
          } else {
            linesSortKey = c.key;
            linesSortDir = c.defaultDir || 'desc';
          }
          linesAllRows = sortLinesRows(linesAllRows);
          linesCurrentPage = 1;
          renderLinesPage();
        });
      }
      const icon = document.createElement('span');
      icon.className = 'filter-icon';
      icon.textContent = '⚙';
      icon.title = 'Filter this column';
      icon.addEventListener('click', (e) => {
        e.stopPropagation();
        showFilterPopover(th, c.key, (c.type||'text'), 'lines');
      });
      th.appendChild(icon);
      theadRow.appendChild(th);
    });
    updateLinesSortIndicators();
  }

  function sortLinesRows(rows) {
    if (!linesSortKey || !rows) return rows;
    rows.sort((a, b) => {
      const av = a[linesSortKey];
      const bv = b[linesSortKey];
      if (typeof av === 'string' || typeof bv === 'string') {
        return linesSortDir === 'asc' ? String(av).localeCompare(String(bv)) : String(bv).localeCompare(String(av));
      }
      return linesSortDir === 'asc' ? (av - bv) : (bv - av);
    });
    return rows;
  }

  function updateLinesSortIndicators() {
    const theadRow = document.getElementById('linesHeadRow');
    theadRow.querySelectorAll('th').forEach(th => {
      th.classList.remove('sorted-asc', 'sorted-desc');
      if (th.dataset.key === linesSortKey) {
        th.classList.add(linesSortDir === 'asc' ? 'sorted-asc' : 'sorted-desc');
      }
    });
  }
  function updateLinesFilterActions() {
    const container = document.getElementById('linesFilterActions');
    if (!container) return;
    const count = linesColumnFilters.size;
    if (count > 0) {
      container.style.display = 'block';
      const info = document.getElementById('linesFiltersInfo');
      if (info) info.textContent = `(${count} active filter${count>1?'s':''})`;
    } else {
      container.style.display = 'none';
    }
  }

  function applyLinesFilters(rows) {
    if (!rows) return [];
    let out = rows;
    for (const [key, f] of linesColumnFilters.entries()) {
      if (!f) continue;
      const type = f.type || 'text';
      if (type === 'number') {
        const hasMin = f.min != null && f.min !== '';
        const hasMax = f.max != null && f.max !== '';
        if (!hasMin && !hasMax) continue;
        const minVal = hasMin ? parseFloat(f.min) : -Infinity;
        const maxVal = hasMax ? parseFloat(f.max) : Infinity;
        out = out.filter(r => {
          const v = Number(r[key]);
          if (!Number.isFinite(v)) return false;
          return v >= minVal && v <= maxVal;
        });
      } else {
        if (!f.pattern) continue;
        let re = null;
        try { re = new RegExp(f.pattern, 'i'); } catch(e) { re = null; }
        if (!re) continue;
        out = out.filter(r => re.test(String(r[key] ?? '')));
      }
    }
    return out;
  }

  function renderLinesPage() {
    const tbody = document.getElementById('linesTableBody');
    const filtered = applyLinesFilters(linesAllRows);
    const totalPages = getTotalPages(filtered.length, linesPageSize);
    const paginatedRows = paginateArray(filtered, linesCurrentPage, linesPageSize);

    tbody.innerHTML = '';
    for (const row of paginatedRows) {
      const tr = document.createElement('tr');
      const actVal = row.act_label || row.act;
      const sceneVal = row.scene_label || row.scene;
      tr.innerHTML = `
        <td>${row.play_title}</td>
        <td>${actVal}</td>
        <td>${sceneVal}</td>
        <td>${row.line_num}</td>
        <td>${row.speaker}</td>
        <td class="line-text">${row.text}</td>
      `;
      tbody.appendChild(tr);
    }

    updateLinesSortIndicators();

    const paginationDiv = document.getElementById('linesPagination');
    paginationDiv.style.display = filtered.length > 25 ? 'flex' : 'none';

    document.getElementById('linesPageInfo').textContent = `Page ${linesCurrentPage} of ${totalPages}`;
    document.getElementById('linesTotalInfo').textContent = `(${filtered.length} total lines)`;

    document.getElementById('linesFirstPage').disabled = linesCurrentPage === 1;
    document.getElementById('linesPrevPage').disabled = linesCurrentPage === 1;
    document.getElementById('linesNextPage').disabled = linesCurrentPage === totalPages;
    document.getElementById('linesLastPage').disabled = linesCurrentPage === totalPages;
    // Apply color scales if enabled
    applyOrClear('#linesResults');
    updateDeepLink();
    updateLinesFilterActions();
  }

  function doLinesSearch() {
    const query = document.getElementById('linesQuery').value.trim();
    if (!query) {
      document.getElementById('linesTableBody').innerHTML = '';
      document.getElementById('linesPagination').style.display = 'none';
      updateLinesFilterActions();
      return;
    }

    const rows = buildLinesRows(query);
    if (!rows) {
      document.getElementById('linesTableBody').innerHTML = '<tr><td colspan="6" class="warning">Invalid search or no data available.</td></tr>';
      document.getElementById('linesPagination').style.display = 'none';
      updateLinesFilterActions();
      return;
    }

    if (rows.length === 0) {
      document.getElementById('linesTableBody').innerHTML = '<tr><td colspan="6" class="muted">No lines matched.</td></tr>';
      document.getElementById('linesPagination').style.display = 'none';
      updateLinesFilterActions();
      return;
    }

    linesAllRows = sortLinesRows(rows);
    linesCurrentPage = 1;
    setLinesHeaders();
    renderLinesPage();
    saveLinesState();
  }

  function checkLinesPendingChanges() {
    const currentState = {
      query: document.getElementById('linesQuery').value.trim(),
      ngramMode: document.getElementById('linesNgramMode').value,
      matchMode: document.getElementById('linesMatchMode').value
    };

    linesPendingChanges = 
      currentState.query !== lastLinesState.query ||
      currentState.ngramMode !== lastLinesState.ngramMode ||
      currentState.matchMode !== lastLinesState.matchMode;

    updateLinesRefreshButton();
  }

  function updateLinesRefreshButton() {
    const btn = document.getElementById('linesRefresh');
    if (!btn) return;
    if (linesPendingChanges) {
      btn.classList.add('refresh-btn-pending');
      btn.textContent = 'Refresh ⟳';
    } else {
      btn.classList.remove('refresh-btn-pending');
      btn.textContent = 'Refresh';
    }
  }

  function saveLinesState() {
    lastLinesState = {
      query: document.getElementById('linesQuery').value.trim(),
      ngramMode: document.getElementById('linesNgramMode').value,
      matchMode: document.getElementById('linesMatchMode').value
    };
    linesPendingChanges = false;
    updateLinesRefreshButton();
  }

  // Lines tab event listeners
  const debouncedDoLinesSearch = debounce(doLinesSearch, 250);
  document.getElementById('linesQuery').addEventListener('keydown', e => { if (e.key === 'Enter') doLinesSearch(); });
  document.getElementById('linesQuery').addEventListener('input', () => { checkLinesPendingChanges(); debouncedDoLinesSearch(); });
  document.getElementById('linesNgramMode').addEventListener('change', () => { checkLinesPendingChanges(); doLinesSearch(); });
  document.getElementById('linesMatchMode').addEventListener('change', () => { checkLinesPendingChanges(); doLinesSearch(); });
  const downloadLinesBtn = document.getElementById('downloadLinesCsv');
  if (downloadLinesBtn) {
    downloadLinesBtn.addEventListener('click', () => {
      const name = `lines-${Date.now()}.csv`;
      downloadTableCsv('#linesResults', name);
    });
  }

  // Lines pagination controls
  document.getElementById('linesFirstPage').addEventListener('click', () => {
    linesCurrentPage = 1;
    renderLinesPage();
  });
  document.getElementById('linesPrevPage').addEventListener('click', () => {
    if (linesCurrentPage > 1) {
      linesCurrentPage--;
      renderLinesPage();
    }
  });
  document.getElementById('linesNextPage').addEventListener('click', () => {
    const totalPages = getTotalPages(linesAllRows.length, linesPageSize);
    if (linesCurrentPage < totalPages) {
      linesCurrentPage++;
      renderLinesPage();
    }
  });
  document.getElementById('linesLastPage').addEventListener('click', () => {
    linesCurrentPage = getTotalPages(linesAllRows.length, linesPageSize);
    renderLinesPage();
  });
  document.getElementById('linesPageSize').addEventListener('change', (e) => {
    linesPageSize = parseInt(e.target.value);
    linesCurrentPage = 1;
    renderLinesPage();
  });

  // initial state for contexts tab (only if no deep link state applied)
  if (!appliedDeepLinkState) {
    gran.value = 'play';
    q.value = 'love';
    doSearch();
  }

  // initial state for ngrams tab - set defaults only if no deep link state
  if (!appliedDeepLinkState) {
    document.getElementById('ngramsQuery').value = 'love';
  
  // Add some interesting characters from different plays
  // We'll add Romeo, Juliet, Hamlet, and Ophelia as they're well-known lovers/tragic figures
  const defaultCharacters = [
    { play: 'Romeo and Juliet', character: 'ROMEO' },
    { play: 'Romeo and Juliet', character: 'JULIET' },
    { play: 'Hamlet', character: 'HAMLET' },
    { play: 'Hamlet', character: 'OPHELIA' }
  ];
  
  defaultCharacters.forEach(({ play, character }) => {
    // Find the character in the characters data
    const charData = characters.find(c => 
      c.play_id && 
      plays.find(p => p.id === c.play_id && p.title === play) && 
      c.character === character
    );
    
    if (charData) {
      const playInfo = plays.find(p => p.id === charData.play_id);
      ngramsSelectedSegments.add({
        type: 'character',
        id: charData.character,
        play_id: charData.play_id,
        label: `${charData.character} (${playInfo.title})`
      });
    }
  });
  
    renderSelectedSegments();
    buildNgramsComparison();
  }
})();
</script>
</body>
</html>
